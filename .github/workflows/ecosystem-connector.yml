# Ecosystem Connector - Unified @cascade AI Automation
# Single trigger point for cost-optimized AI routing
# All actions pinned to exact SHAs for security and reproducibility
#
# PRIME DIRECTIVES (Enterprise Standards):
# 1. SHA Pinning - All GitHub Actions must use exact commit SHAs
# 2. Token Standards - Use CI_GITHUB_TOKEN pattern consistently
# 3. Conventional Commits - PR titles must follow conventional commit format
# 4. Security Scanning - No hardcoded secrets or tokens in code
# 5. Required Files - Repos must have CLAUDE.md and AGENTS.md
# 6. Permissions - Workflows must declare minimum required permissions

name: Ecosystem Connector

on:
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # DATA PLANE: PR lifecycle events
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  pull_request:
    types: 
      - opened           # New PR ‚Üí create tracking issue
      - synchronize      # New commits ‚Üí update synthesis
      - reopened         # PR reopened ‚Üí reopen tracking issue
      - ready_for_review # Draft -> Ready ‚Üí trigger synthesis
      - labeled          # Label added (for sync/auto-merge)
      - unlabeled        # Label removed
      - closed           # PR closed/merged ‚Üí close tracking issue
  pull_request_review:
    types: [submitted, dismissed]
  
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # CONTROL PLANE: Tracking issue events (our KV store)
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  issues:
    types:
      - labeled          # State transition (blocked‚Üíreview‚Üíready)
      - unlabeled        # State regression
      - edited           # Manual update to synthesis
      - closed           # Cleanup
  
  # Commands on tracking issues OR PRs
  issue_comment:
    types: [created]
  
  # Milestone events for release tracking
  milestone:
    types: [closed]      # Release cut ‚Üí audit all linked PRs
  
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # CI EVENTS: Trigger merge assessment
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  check_suite:
    types: [completed]
  check_run:
    types: [completed]
  status: {}
  
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # PROPAGATION: Main branch changes
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  push:
    branches: [main]
    paths:
      - '.github/workflows/ecosystem-connector.yml'
      - 'repository-files/always-sync/**'

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

concurrency:
  group: ecosystem-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

env:
  # Comment deduplication - check for existing comments before posting
  # Each job should check: gh pr view $PR --json comments --jq '.comments[] | select(.body | contains("MARKER")) | .id' | head -1
  COMMENT_COOLDOWN_MINUTES: 5

jobs:
  # ============================================================
  # MAIN BRANCH: Propagate ecosystem-connector changes
  # ============================================================
  propagate-on-main:
    name: Propagate to Ecosystem
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Trigger ecosystem sync
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          echo "üöÄ ecosystem-connector updated on main - triggering sync..."
          
          # Trigger the ecosystem-sync workflow
          gh workflow run ecosystem-sync.yml --repo ${{ github.repository }} || echo "Sync workflow triggered or already running"
          
          echo "‚úÖ Sync triggered - changes will propagate to all org control-centers"

  # ============================================================
  # PRIME DIRECTIVE: Enforce SHA pinning for GitHub Actions
  # ============================================================
  pin-actions:
    name: Pin Actions
    if: github.event_name == 'pull_request' && !github.event.pull_request.draft
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Check for workflow changes
        id: check
        run: |
          # Check if PR contains workflow files
          WORKFLOW_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD -- '.github/workflows/*.yml' '.github/workflows/*.yaml' 2>/dev/null || echo "")
          
          if [ -z "$WORKFLOW_FILES" ]; then
            echo "No workflow files changed"
            echo "has_workflows=false" >> $GITHUB_OUTPUT
          else
            echo "Workflow files changed:"
            echo "$WORKFLOW_FILES"
            echo "has_workflows=true" >> $GITHUB_OUTPUT
            echo "$WORKFLOW_FILES" > /tmp/workflow_files.txt
          fi

      - name: Enforce SHA pinning
        if: steps.check.outputs.has_workflows == 'true'
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # Known latest action SHAs (update periodically)
          declare -A ACTION_SHAS
          ACTION_SHAS["actions/checkout"]="8e8c483db84b4bee98b60c0593521ed34d9990e8|v6.0.1"
          ACTION_SHAS["actions/setup-node"]="49933ea5288caeca8642d1e84afbd3f7d6820020|v4.4.0"
          ACTION_SHAS["actions/setup-python"]="a26af69be951a213d495a4c3e4e4022e16d87065|v5.6.0"
          ACTION_SHAS["actions/cache"]="5a3ec84eff668545956fd18022155c47e93e2684|v4.2.3"
          ACTION_SHAS["actions/upload-artifact"]="ea165f8d65b6e75b540449e92b4886f43607fa02|v4.6.2"
          ACTION_SHAS["actions/download-artifact"]="fa0a91b85d4f404e444e00e005971372dc801d16|v4.1.8"
          ACTION_SHAS["github/codeql-action/init"]="fca7ace96b7d713c7035871441bd52efbe39e27e|v3.28.19"
          ACTION_SHAS["github/codeql-action/analyze"]="fca7ace96b7d713c7035871441bd52efbe39e27e|v3.28.19"
          ACTION_SHAS["github/codeql-action/autobuild"]="fca7ace96b7d713c7035871441bd52efbe39e27e|v3.28.19"
          ACTION_SHAS["peter-evans/create-pull-request"]="271a8d0340265f705b14b6f32688f5d79ebeba24|v7.0.8"
          ACTION_SHAS["anthropics/claude-code-action"]="154d0de144ff82240e1c3deedff56280381fd122|beta"
          
          VIOLATIONS=""
          FIXES=""
          
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            [ ! -f "$file" ] && continue
            
            echo "Checking $file..."
            
            # Find uses: lines with version tags (not SHAs)
            while IFS= read -r line; do
              [ -z "$line" ] && continue
              
              # Extract action reference (e.g., actions/checkout@v4)
              ACTION=$(echo "$line" | grep -oP 'uses:\s*\K[^@]+' || echo "")
              VERSION=$(echo "$line" | grep -oP '@\K[^\s#]+' || echo "")
              
              [ -z "$ACTION" ] && continue
              
              # Skip if already a SHA (40 hex chars)
              if [[ "$VERSION" =~ ^[a-f0-9]{40}$ ]]; then
                echo "  ‚úÖ $ACTION@$VERSION (already pinned)"
                continue
              fi
              
              # Check if we have a known SHA for this action
              if [[ -n "${ACTION_SHAS[$ACTION]}" ]]; then
                SHA_VER="${ACTION_SHAS[$ACTION]}"
                SHA="${SHA_VER%%|*}"
                VER="${SHA_VER##*|}"
                
                VIOLATIONS="$VIOLATIONS\n- \`$ACTION@$VERSION\` should be \`$ACTION@$SHA # $VER\`"
                FIXES="$FIXES\n  sed -i 's|$ACTION@$VERSION|$ACTION@$SHA # $VER|g' $file"
              else
                # Unknown action - just flag it
                VIOLATIONS="$VIOLATIONS\n- \`$ACTION@$VERSION\` should be pinned to exact SHA"
              fi
              
            done < <(grep -E '^\s*-?\s*uses:' "$file" 2>/dev/null || true)
            
          done < /tmp/workflow_files.txt
          
          if [ -n "$VIOLATIONS" ]; then
            PR_NUM=${{ github.event.pull_request.number }}
            MARKER="Prime Directive: Pin GitHub Actions"
            
            # Check for existing comment (dedup)
            EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | head -1)
            if [ -n "$EXISTING" ]; then
              echo "Pin actions comment already exists, skipping"
              exit 0
            fi
            
            BODY="## üîí **$MARKER to SHAs**
          
          The following actions need to be pinned to exact commit SHAs for security and reproducibility:
          $(echo -e "$VIOLATIONS")
          
          ### Why?
          - **Security**: Tag references can be moved, SHAs cannot
          - **Reproducibility**: Exact same code runs every time
          - **Audit trail**: Know exactly what code executed
          
          ### Quick Fix
          \`\`\`bash$(echo -e "$FIXES")
          \`\`\`
          
          ---
          *Use \`@cascade pin these actions\` for automatic fixing*"
            
            gh pr comment $PR_NUM --body "$BODY"
            
            echo "::warning::Workflow files contain unpinned action references"
          else
            echo "‚úÖ All actions are properly pinned to SHAs"
          fi

  # ============================================================
  # REVIEW SYNTHESIS: Tracking Issue as KV Store
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # Pattern: GitHub Issue as persistent, queryable state store
  #
  # KEY: "synthesis-pr-{number}" (issue title)
  # VALUE: Issue body (structured markdown with metadata)
  # INDEXES: Labels (synthesis, blocked, review, ready, pr-{n})
  # TTL: Auto-close when PR merges (linked issue)
  #
  # Flow:
  #   1. PR opened ‚Üí create tracking issue
  #   2. AI feedback ‚Üí gather, resolve, update issue body
  #   3. State change ‚Üí update labels (blocked/review/ready)
  #   4. PR merged ‚Üí close tracking issue
  # ============================================================
  review-synthesis:
    name: Review Synthesis (KV Store)
    if: |
      github.event_name == 'pull_request_review' ||
      github.event_name == 'pull_request' ||
      (github.event_name == 'issue_comment' && 
       contains(github.event.comment.body, '@cascade synthesize'))
    runs-on: ubuntu-latest
    outputs:
      tracking_issue: ${{ steps.synthesis.outputs.tracking_issue }}
      verdict: ${{ steps.synthesis.outputs.verdict }}
    steps:
      - name: Gather ‚Üí Resolve ‚Üí Store in Tracking Issue
        id: synthesis
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          OLLAMA_API_URL: ${{ vars.OLLAMA_API_URL || 'https://api.ollama.com' }}
        run: |
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # RESOLVE PR CONTEXT
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          case "${{ github.event_name }}" in
            issue_comment) PR_NUM="${{ github.event.issue.number }}" ;;
            *) PR_NUM="${{ github.event.pull_request.number }}" ;;
          esac
          
          [ -z "$PR_NUM" ] && echo "No PR number" && exit 0
          
          # Get PR details
          PR_DATA=$(gh pr view $PR_NUM --json title,url,author,headRefName,baseRefName 2>/dev/null || echo "{}")
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title // "Unknown"')
          PR_URL=$(echo "$PR_DATA" | jq -r '.url // ""')
          PR_AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login // "unknown"')
          PR_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName // "unknown"')
          
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë  üì¶ KV STORE: Tracking Issue for PR #$PR_NUM"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          
          OWNER="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          AI_AGENTS="copilot|github-actions|coderabbitai|gemini|cursor|amazon-q|dependabot|bugbot|claude|sonarcloud|codacy|snyk"
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 1: GET OR CREATE TRACKING ISSUE (KV key lookup)
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "üîë Step 1: KV Lookup - tracking issue..."
          
          ISSUE_KEY="synthesis-pr-$PR_NUM"
          
          # Ensure labels exist
          gh label create "synthesis" --description "PR synthesis tracking issue" --color "7057FF" 2>/dev/null || true
          gh label create "queue-blocked" --description "PR blocked by critical issues" --color "B60205" 2>/dev/null || true
          gh label create "queue-review" --description "PR needs review attention" --color "FBCA04" 2>/dev/null || true
          gh label create "queue-ready" --description "PR ready for merge" --color "0E8A16" 2>/dev/null || true
          
          # Search for existing tracking issue
          TRACKING_ISSUE=$(gh issue list --label "synthesis" --search "$ISSUE_KEY in:title" --json number,state --jq '.[0].number // empty' 2>/dev/null)
          
          if [ -z "$TRACKING_ISSUE" ]; then
            echo "  Creating new tracking issue..."
            
            INITIAL_BODY="# üî¨ Synthesis: PR #$PR_NUM

          > **Linked PR:** $PR_URL
          > **Author:** @$PR_AUTHOR
          > **Branch:** \`$PR_BRANCH\`

          ---

          ## üìä Queue State

          | Metric | Value |
          |--------|-------|
          | Reviews Analyzed | 0 |
          | Active Threads | 0 |
          | Resolved | 0 |
          | Last Updated | $(date -u +%Y-%m-%dT%H:%M:%SZ) |

          ## üéØ Verdict

          \`PENDING\` - Awaiting AI feedback

          ## üìù Feedback Queue

          _No feedback collected yet._

          ---

          <sub>ü§ñ Managed by CASCADE | Commands: \`@cascade synthesize\`, \`@cascade address\`</sub>"
            
            TRACKING_ISSUE=$(gh issue create \
              --title "$ISSUE_KEY: $PR_TITLE" \
              --body "$INITIAL_BODY" \
              --label "synthesis" \
              --json number --jq '.number')
            
            # Link to PR via comment
            gh pr comment $PR_NUM --body "üì¶ **Tracking Issue Created:** #$TRACKING_ISSUE

          All AI feedback will be synthesized there. Use \`@cascade\` commands on the tracking issue for targeted actions."
            
            echo "  ‚úÖ Created tracking issue #$TRACKING_ISSUE"
          else
            echo "  ‚úÖ Found existing tracking issue #$TRACKING_ISSUE"
          fi
          
          echo "tracking_issue=$TRACKING_ISSUE" >> $GITHUB_OUTPUT
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 2: GATHER all AI feedback from PR
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "üì• Step 2: Gathering AI feedback from PR..."
          
          QUERY='query($owner: String!, $repo: String!, $pr: Int!) {
            repository(owner: $owner, name: $repo) {
              pullRequest(number: $pr) {
                reviews(first: 100) {
                  nodes {
                    author { login }
                    body
                    state
                    submittedAt
                  }
                }
                reviewThreads(first: 100) {
                  nodes {
                    id
                    isResolved
                    isOutdated
                    path
                    line
                    comments(first: 5) {
                      nodes {
                        author { login }
                        body
                      }
                    }
                  }
                }
              }
            }
          }'
          
          RESULT=$(gh api graphql -f query="$QUERY" -f owner="$OWNER" -f repo="$REPO" -F pr="$PR_NUM" 2>/dev/null || echo "{}")
          
          # Extract and count
          REVIEWS=$(echo "$RESULT" | jq --arg agents "$AI_AGENTS" '[.data.repository.pullRequest.reviews.nodes[]? | select(.author.login | test($agents; "i"))]' 2>/dev/null || echo "[]")
          THREADS=$(echo "$RESULT" | jq --arg agents "$AI_AGENTS" '[.data.repository.pullRequest.reviewThreads.nodes[]? | select(.isResolved == false) | select(.comments.nodes[0].author.login | test($agents; "i"))]' 2>/dev/null || echo "[]")
          OUTDATED_IDS=$(echo "$RESULT" | jq -r --arg agents "$AI_AGENTS" '.data.repository.pullRequest.reviewThreads.nodes[]? | select(.isOutdated == true and .isResolved == false) | select(.comments.nodes[0].author.login | test($agents; "i")) | .id' 2>/dev/null || echo "")
          
          REVIEW_COUNT=$(echo "$REVIEWS" | jq 'length')
          THREAD_COUNT=$(echo "$THREADS" | jq 'length')
          CRITICAL_COUNT=$(echo "$THREADS" | jq '[.[] | select(.comments.nodes[0].body | test("security|vulnerability|critical|breaking"; "i"))] | length')
          
          echo "  Found: $REVIEW_COUNT reviews, $THREAD_COUNT threads, $CRITICAL_COUNT critical"
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 3: RESOLVE outdated threads (dequeue old items)
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "üßπ Step 3: Resolving outdated threads..."
          
          RESOLVED=0
          for TID in $OUTDATED_IDS; do
            [ -z "$TID" ] && continue
            gh api graphql -f query='mutation($id: ID!) { resolveReviewThread(input: {threadId: $id}) { thread { isResolved } } }' -f id="$TID" 2>/dev/null && RESOLVED=$((RESOLVED + 1))
          done
          echo "  ‚úÖ Resolved $RESOLVED outdated threads"
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 4: DETERMINE VERDICT
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "‚öñÔ∏è Step 4: Determining verdict..."
          
          if [ "$CRITICAL_COUNT" -gt 0 ]; then
            VERDICT="BLOCKED"
            VERDICT_EMOJI="üî¥"
            VERDICT_LABEL="queue-blocked"
          elif [ "$THREAD_COUNT" -gt 0 ]; then
            VERDICT="REVIEW"
            VERDICT_EMOJI="üü°"
            VERDICT_LABEL="queue-review"
          else
            VERDICT="READY"
            VERDICT_EMOJI="‚úÖ"
            VERDICT_LABEL="queue-ready"
          fi
          
          echo "  Verdict: $VERDICT_EMOJI $VERDICT"
          echo "verdict=$VERDICT" >> $GITHUB_OUTPUT
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 5: BUILD FEEDBACK QUEUE (for issue body)
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "üìù Step 5: Building feedback queue..."
          
          FEEDBACK_LIST=""
          if [ "$THREAD_COUNT" -gt 0 ]; then
            FEEDBACK_LIST=$(echo "$THREADS" | jq -r '
              .[] | 
              "- [ ] **\(.comments.nodes[0].author.login)** on `\(.path):\(.line // "?")`\n  > \(.comments.nodes[0].body | split("\n")[0])"
            ' 2>/dev/null | head -30)
          else
            FEEDBACK_LIST="_No active feedback items._"
          fi
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 6: UPDATE TRACKING ISSUE (KV store write)
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "üíæ Step 6: Updating tracking issue (KV write)..."
          
          UPDATED_BODY="# üî¨ Synthesis: PR #$PR_NUM

          > **Linked PR:** $PR_URL
          > **Author:** @$PR_AUTHOR
          > **Branch:** \`$PR_BRANCH\`

          ---

          ## üìä Queue State

          | Metric | Value |
          |--------|-------|
          | Reviews Analyzed | $REVIEW_COUNT |
          | Active Threads | $THREAD_COUNT |
          | Critical Issues | $CRITICAL_COUNT |
          | Resolved This Run | $RESOLVED |
          | Last Updated | $(date -u +%Y-%m-%dT%H:%M:%SZ) |

          ## üéØ Verdict

          $VERDICT_EMOJI **$VERDICT**

          ## üìù Feedback Queue

          $FEEDBACK_LIST

          ---

          ### ü§ñ CASCADE Commands

          Use these commands **on this issue** for targeted AI actions:

          | Command | Action |
          |---------|--------|
          | \`@cascade address\` | AI fixes all feedback items |
          | \`@cascade synthesize\` | Re-gather and re-synthesize |
          | \`@cascade merge\` | Force merge assessment |

          <sub>Updated by Ecosystem Connector</sub>"
          
          gh issue edit $TRACKING_ISSUE --body "$UPDATED_BODY"
          
          # Update labels (remove old state, add new)
          gh issue edit $TRACKING_ISSUE --remove-label "queue-blocked,queue-review,queue-ready" 2>/dev/null || true
          gh issue edit $TRACKING_ISSUE --add-label "$VERDICT_LABEL"
          
          echo "  ‚úÖ Tracking issue #$TRACKING_ISSUE updated with verdict: $VERDICT"
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 7: Handle PR lifecycle (close issue if PR closed)
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          if [ "${{ github.event.action }}" = "closed" ]; then
            echo ""
            echo "üèÅ PR closed - closing tracking issue..."
            
            if [ "${{ github.event.pull_request.merged }}" = "true" ]; then
              gh issue close $TRACKING_ISSUE --comment "‚úÖ PR #$PR_NUM merged successfully."
            else
              gh issue close $TRACKING_ISSUE --comment "‚ùå PR #$PR_NUM closed without merge."
            fi
          fi
          
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë  ‚úÖ KV STORE UPDATED                                       ‚ïë"
          echo "‚ïë  Key: $ISSUE_KEY                                           ‚ïë"
          echo "‚ïë  Tracking Issue: #$TRACKING_ISSUE                          ‚ïë"
          echo "‚ïë  Verdict: $VERDICT                                         ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"

  # Automatic AI review on new/updated PRs
  auto-review:
    name: Auto Review
    if: github.event_name == 'pull_request' && !github.event.pull_request.draft
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: AI Review
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          MARKER="Cascade Auto-Review"
          
          # Check for existing review comment (dedup)
          EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | head -1)
          if [ -n "$EXISTING" ]; then
            echo "Review comment already exists, skipping"
            exit 0
          fi
          
          DIFF=$(git diff origin/${{ github.event.pull_request.base.ref }}...HEAD -- '*.py' '*.ts' '*.js' '*.tsx' '*.jsx' '*.go' '*.rs' | head -3000)
          
          if [ -z "$DIFF" ]; then
            echo "No code changes to review"
            exit 0
          fi
          
          gh pr comment $PR_NUM --body "ü§ñ **$MARKER**
          
          Analyzing PR changes..."

  # Unified @cascade trigger - routes to optimal AI agent
  cascade:
    name: Cascade
    if: |
      github.event_name == 'issue_comment' &&
      contains(github.event.comment.body, '@cascade') &&
      !contains(github.event.comment.body, '@cascade rebase') &&
      !contains(github.event.comment.body, '@cascade synthesize')
    runs-on: ubuntu-latest
    outputs:
      route: ${{ steps.route.outputs.agent }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Route to optimal agent
        id: route
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          echo "üîÄ Cascade routing..."
          
          # Extract task from comment
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          # Determine optimal agent based on task keywords
          AGENT="claude"  # Default to Claude for most tasks
          
          # Quick questions/explanations -> Ollama (cheapest)
          if echo "$TASK" | grep -qiE "(explain|what is|how does|why|describe|summarize|question)"; then
            AGENT="ollama"
          fi
          
          # Multi-file refactors, large changes -> Jules
          if echo "$TASK" | grep -qiE "(refactor|rename across|update all|migrate|bulk|across files|multi-file)"; then
            AGENT="jules"
          fi
          
          # Long-running, complex debugging -> Cursor
          if echo "$TASK" | grep -qiE "(debug|investigate|long|complex|deep dive|root cause|trace)"; then
            AGENT="cursor"
          fi
          
          # Merge conflicts, rebase -> Claude (can handle git)
          if echo "$TASK" | grep -qiE "(rebase|merge|conflict|resolve|sync with main)"; then
            AGENT="claude"
          fi
          
          # Code review, fix issues -> Claude
          if echo "$TASK" | grep -qiE "(review|fix|address feedback|implement|add|update|change)"; then
            AGENT="claude"
          fi
          
          echo "agent=$AGENT" >> $GITHUB_OUTPUT
          echo "Selected agent: $AGENT"
          
          # Post acknowledgment (no dedup needed - user explicitly triggered)
          echo "agent=$AGENT" >> $GITHUB_OUTPUT
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "üåä **Cascade** ‚Üí **$AGENT**: $TASK"
          else
            gh issue comment $ISSUE_NUM --body "üåä **Cascade** ‚Üí **$AGENT**: $TASK"
          fi

  # Route: Claude (default for most tasks)
  cascade-claude:
    name: Claude
    needs: cascade
    if: needs.cascade.outputs.route == 'claude'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - uses: anthropics/claude-code-action@154d0de144ff82240e1c3deedff56280381fd122 # latest
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.CI_GITHUB_TOKEN }}
          allowed_bots: '*'
          trigger_phrase: '@cascade'

  # Route: Ollama (cheapest - for quick questions)
  cascade-ollama:
    name: Ollama
    needs: cascade
    if: needs.cascade.outputs.route == 'ollama'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Query Ollama
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          OLLAMA_API_URL: ${{ vars.OLLAMA_API_URL || 'https://api.ollama.com' }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          ISSUE_NUM="${{ github.event.issue.number }}"
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          
          # Simple acknowledgment (Ollama API integration would go here)
          RESPONSE="ü§ñ **Ollama Response**
          
          Processing: $TASK
          
          _(Cost-optimized quick response)_"
          
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "$RESPONSE"
          else
            gh issue comment $ISSUE_NUM --body "$RESPONSE"
          fi

  # Route: Jules (for multi-file refactors)
  cascade-jules:
    name: Jules
    needs: cascade
    if: needs.cascade.outputs.route == 'jules'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Delegate to Jules
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          GOOGLE_JULES_API_KEY: ${{ secrets.GOOGLE_JULES_API_KEY }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          ISSUE_NUM="${{ github.event.issue.number }}"
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          
          RESPONSE="ü§ñ **Jules Session**
          
          Task: $TASK
          
          Jules will create a session for multi-file refactoring.
          _(Optimized for large-scale changes)_"
          
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "$RESPONSE"
          else
            gh issue comment $ISSUE_NUM --body "$RESPONSE"
          fi

  # Route: Cursor (for long-running complex tasks)
  cascade-cursor:
    name: Cursor
    needs: cascade
    if: needs.cascade.outputs.route == 'cursor'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Delegate to Cursor
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          ISSUE_NUM="${{ github.event.issue.number }}"
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          
          RESPONSE="ü§ñ **Cursor Agent**
          
          Task: $TASK
          
          Cursor background agent spawned for deep investigation.
          _(Optimized for complex debugging)_"
          
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "$RESPONSE"
          else
            gh issue comment $ISSUE_NUM --body "$RESPONSE"
          fi

  # Legacy support: direct @claude still works
  claude-direct:
    name: Claude (Direct)
    if: |
      github.event_name == 'issue_comment' &&
      contains(github.event.comment.body, '@claude') &&
      !contains(github.event.comment.body, '@cascade')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - uses: anthropics/claude-code-action@154d0de144ff82240e1c3deedff56280381fd122 # latest
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.CI_GITHUB_TOKEN }}
          allowed_bots: '*'

  # ============================================================
  # CI-FIX: Attempt to fix CI failures
  # ============================================================
  ci-fix:
    name: CI Fix
    if: |
      github.event_name == 'check_suite' &&
      github.event.check_suite.conclusion == 'failure' &&
      github.event.check_suite.pull_requests[0] != null
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}
          ref: ${{ github.event.check_suite.head_branch }}

      - name: Analyze and suggest fix
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=$(echo '${{ toJson(github.event.check_suite.pull_requests) }}' | jq -r '.[0].number')
          
          if [ "$PR_NUM" = "null" ] || [ -z "$PR_NUM" ]; then
            echo "No PR associated with this check suite"
            exit 0
          fi
          
          # Get failed check runs
          FAILED=$(gh api repos/${{ github.repository }}/check-suites/${{ github.event.check_suite.id }}/check-runs \
            --jq '.check_runs[] | select(.conclusion == "failure") | .name' | head -5)
          
          # Check for recent CI failure comment (within last 3 comments)
          MARKER="CI Failure Detected"
          RECENT=$(gh pr view $PR_NUM --json comments --jq ".comments[-3:] | .[] | select(.body | contains(\"$MARKER\")) | .id" | head -1)
          if [ -n "$RECENT" ]; then
            echo "Recent CI failure comment exists, skipping"
            exit 0
          fi
          
          gh pr comment $PR_NUM --body "‚ùå **$MARKER**

          Failed checks:
          \`\`\`
          $FAILED
          \`\`\`

          Use \`@cascade fix the CI failures\` for AI-assisted debugging."

  # ============================================================
  # AUTO-MERGE: Merge when ready
  # ============================================================
  auto-merge:
    name: Auto Merge
    if: |
      github.event_name == 'pull_request_review' &&
      github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - name: Check and merge
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          
          # Check if auto-merge label exists
          HAS_AUTO=$(gh pr view $PR_NUM --json labels --jq '.labels[].name' | grep -c "auto-merge" || true)
          
          if [ "$HAS_AUTO" -eq 0 ]; then
            echo "No auto-merge label, skipping"
            exit 0
          fi
          
          # Check all status checks
          STATUS=$(gh pr checks $PR_NUM --json state --jq '.[] | select(.state != "SUCCESS" and .state != "SKIPPED") | .state' | head -1)
          
          if [ -n "$STATUS" ]; then
            echo "Checks not all passing, waiting..."
            exit 0
          fi
          
          # Merge
          gh pr merge $PR_NUM --squash --delete-branch --body "Auto-merged after approval"
          
          echo "‚úÖ PR #$PR_NUM merged"

  # ============================================================
  # SYNC-TRIAGE: Handle sync PRs from control center
  # ============================================================
  sync-triage:
    name: Sync Triage
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'opened' &&
      contains(github.event.pull_request.title, 'sync:')
    runs-on: ubuntu-latest
    steps:
      - name: Auto-approve sync PRs
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          
          # Mark ready for review if draft
          if [ "${{ github.event.pull_request.draft }}" = "true" ]; then
            echo "Converting draft to ready for review..."
            gh pr ready $PR_NUM || true
          fi
          
          # Add label for tracking
          gh pr edit $PR_NUM --add-label "sync,auto-merge"
          
          # Approve if from trusted source
          AUTHOR="${{ github.event.pull_request.user.login }}"
          
          if [[ "$AUTHOR" == *"[bot]"* ]] || [ "$AUTHOR" = "jbcom" ]; then
            gh pr review $PR_NUM --approve --body "‚úÖ Approved: Sync from control center"
          fi

  # ============================================================
  # AUTO-REBASE: Rebase PRs with merge conflicts
  # ============================================================
  auto-rebase:
    name: Auto Rebase
    if: |
      (github.event_name == 'pull_request' &&
       (github.event.action == 'synchronize' || github.event.action == 'opened')) ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, '@cascade rebase'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Check and rebase if needed
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # Get PR info
          if [ "${{ github.event_name }}" = "issue_comment" ]; then
            PR_NUM="${{ github.event.issue.number }}"
            # Verify it's a PR, not an issue
            if [ -z "${{ github.event.issue.pull_request }}" ]; then
              echo "Not a PR, skipping"
              exit 0
            fi
          else
            PR_NUM="${{ github.event.pull_request.number }}"
          fi
          
          # Get PR details
          PR_DATA=$(gh pr view $PR_NUM --json headRefName,baseRefName,mergeable,mergeStateStatus)
          HEAD_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
          BASE_BRANCH=$(echo "$PR_DATA" | jq -r '.baseRefName')
          MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')
          MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus')
          
          echo "PR #$PR_NUM: $HEAD_BRANCH -> $BASE_BRANCH"
          echo "Mergeable: $MERGEABLE, State: $MERGE_STATE"
          
          # Check if rebase is needed
          if [ "$MERGEABLE" = "CONFLICTING" ] || [ "$MERGE_STATE" = "BEHIND" ] || [ "$MERGE_STATE" = "DIRTY" ]; then
            echo "üîÑ Rebase needed..."
            
            # Configure git
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            # Fetch all branches
            git fetch origin $BASE_BRANCH
            git fetch origin $HEAD_BRANCH
            
            # Checkout the PR branch
            git checkout $HEAD_BRANCH
            
            # Attempt rebase
            if git rebase origin/$BASE_BRANCH; then
              echo "‚úÖ Rebase successful"
              
              # Force push with lease
              if git push --force-with-lease origin $HEAD_BRANCH; then
                echo "‚úÖ Force push successful"
                # No comment on success - reduces noise
              else
                echo "‚ùå Force push failed"
                # Only comment on failure, check for existing
                MARKER="Auto-Rebase Failed"
                EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | tail -1)
                [ -z "$EXISTING" ] && gh pr comment $PR_NUM --body "‚ö†Ô∏è **$MARKER** - Rebase succeeded but force push failed. Please rebase manually."
              fi
            else
              echo "‚ùå Rebase failed - conflicts require manual resolution"
              git rebase --abort 2>/dev/null || true
              
              # Only comment if no recent failure comment
              MARKER="Auto-Rebase Failed"
              EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | tail -1)
              [ -z "$EXISTING" ] && gh pr comment $PR_NUM --body "‚ö†Ô∏è **$MARKER** - Conflicts require manual resolution. Use \`@cascade resolve conflicts\` for help."
            fi
          else
            echo "‚úÖ No rebase needed - PR is up to date"
          fi

  # ============================================================
  # MERGE-READY: Check if PR is ready to merge and do it
  # ============================================================
  merge-ready:
    name: Merge Ready
    if: |
      (github.event_name == 'check_suite' &&
       github.event.check_suite.conclusion == 'success') ||
      (github.event_name == 'pull_request' &&
       github.event.action == 'synchronize') ||
      (github.event_name == 'pull_request_review' &&
       github.event.review.state == 'approved')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Check and merge eligible PRs
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # Get PR number(s) based on event type
          if [ "${{ github.event_name }}" = "check_suite" ]; then
            PRS='${{ toJson(github.event.check_suite.pull_requests) }}'
            PR_NUMS=$(echo "$PRS" | jq -r '.[].number' 2>/dev/null || echo "")
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_NUMS="${{ github.event.pull_request.number }}"
          elif [ "${{ github.event_name }}" = "pull_request_review" ]; then
            PR_NUMS="${{ github.event.pull_request.number }}"
          else
            PR_NUMS=""
          fi
          
          for PR_NUM in $PR_NUMS; do
            [ -z "$PR_NUM" ] && continue
            [ "$PR_NUM" = "null" ] && continue
            
            echo "Checking PR #$PR_NUM..."
            
            # Get PR details
            PR_DATA=$(gh pr view $PR_NUM --json labels,reviewDecision,mergeable,mergeStateStatus,isDraft)
            
            IS_DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft')
            MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')
            MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus')
            REVIEW=$(echo "$PR_DATA" | jq -r '.reviewDecision')
            HAS_AUTO=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "auto-merge" || echo "0")
            HAS_SYNC=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "sync" || echo "0")
            
            echo "  Draft: $IS_DRAFT, Mergeable: $MERGEABLE, State: $MERGE_STATE"
            echo "  Review: $REVIEW, Auto-merge: $HAS_AUTO, Sync: $HAS_SYNC"
            
            # Skip drafts
            if [ "$IS_DRAFT" = "true" ]; then
              echo "  Skipping - draft PR"
              continue
            fi
            
            # Check if auto-merge eligible
            if [ "$HAS_AUTO" -eq 0 ] && [ "$HAS_SYNC" -eq 0 ]; then
              echo "  Skipping - no auto-merge or sync label"
              continue
            fi
            
            # Check if behind - trigger rebase (but don't spam)
            if [ "$MERGE_STATE" = "BEHIND" ] || [ "$MERGEABLE" = "CONFLICTING" ]; then
              # Check if we already requested rebase recently
              RECENT_REBASE=$(gh pr view $PR_NUM --json comments --jq '.comments[-5:] | .[] | select(.body | contains("@cascade rebase")) | .id' | head -1)
              if [ -z "$RECENT_REBASE" ]; then
                echo "  PR needs rebase, triggering..."
                gh pr comment $PR_NUM --body "@cascade rebase"
              else
                echo "  PR needs rebase but already requested recently"
              fi
              continue
            fi
            
            # Check if ready to merge
            if [ "$MERGEABLE" = "MERGEABLE" ] && [ "$MERGE_STATE" = "CLEAN" ]; then
              # Sync PRs can merge without review approval
              if [ "$HAS_SYNC" -gt 0 ]; then
                echo "  ‚úÖ Merging sync PR..."
                gh pr merge $PR_NUM --squash --delete-branch --body "Auto-merged: sync from control center" || echo "  Merge failed"
              elif [ "$REVIEW" = "APPROVED" ]; then
                echo "  ‚úÖ Merging approved PR..."
                gh pr merge $PR_NUM --squash --delete-branch --body "Auto-merged after approval" || echo "  Merge failed"
              else
                echo "  Skipping - awaiting review approval"
              fi
            else
              echo "  Skipping - not in mergeable state"
            fi
          done

  # ============================================================
  # DRAFT-READY: Convert drafts to ready when CI passes
  # ============================================================
  draft-ready:
    name: Draft Ready
    if: |
      github.event_name == 'check_suite' &&
      github.event.check_suite.conclusion == 'success' &&
      github.event.check_suite.pull_requests[0] != null
    runs-on: ubuntu-latest
    steps:
      - name: Mark ready if draft and CI passed
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=$(echo '${{ toJson(github.event.check_suite.pull_requests) }}' | jq -r '.[0].number')
          
          if [ "$PR_NUM" = "null" ] || [ -z "$PR_NUM" ]; then
            exit 0
          fi
          
          # Check if PR is draft
          IS_DRAFT=$(gh pr view $PR_NUM --json isDraft --jq '.isDraft')
          
          if [ "$IS_DRAFT" = "true" ]; then
            echo "CI passed - converting draft PR #$PR_NUM to ready for review"
            gh pr ready $PR_NUM
            # No comment - the ready_for_review event will trigger auto-review
          fi

  # ============================================================
  # MERGE QUEUE CONSUMER: Read fixed point ‚Üí Evaluate ‚Üí Decide
  # ============================================================
  # Pattern: Feedback Merge Queue
  #   PRODUCERS: AI reviewers (Copilot, Gemini, CodeRabbit, etc.)
  #   QUEUE: Fixed-point synthesis comment (updated by review-synthesis)
  #   CONSUMER: This job - reads queue state, decides on merge
  #
  # Division of labor (backportable to @agentic packages):
  #   review-synthesis = @agentic/triage (primitives)
  #   merge-assess = @agentic/control (decisions)
  # ============================================================
  merge-assess:
    name: Merge Queue Consumer
    needs: [review-synthesis]
    if: always()  # Run even if synthesis skipped (no feedback yet = OK to merge)
    runs-on: ubuntu-latest
    steps:
      - name: Consume queue and assess merge eligibility
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 1: Resolve PR number from event
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          case "${{ github.event_name }}" in
            pull_request) PR_NUM="${{ github.event.pull_request.number }}" ;;
            pull_request_review) PR_NUM="${{ github.event.pull_request.number }}" ;;
            issue_comment) PR_NUM="${{ github.event.issue.number }}" ;;
            check_suite) PR_NUM=$(echo '${{ toJson(github.event.check_suite.pull_requests) }}' | jq -r '.[0].number // empty') ;;
            check_run) PR_NUM=$(echo '${{ toJson(github.event.check_run.pull_requests) }}' | jq -r '.[0].number // empty') ;;
            status)
              COMMIT="${{ github.event.commit.sha }}"
              PR_NUM=$(gh pr list --state open --json number,headRefOid --jq ".[] | select(.headRefOid == \"$COMMIT\") | .number" 2>/dev/null | head -1)
              ;;
            *) PR_NUM="" ;;
          esac
          
          [ -z "$PR_NUM" ] || [ "$PR_NUM" = "null" ] && echo "No PR context" && exit 0
          
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë  üéØ MERGE QUEUE CONSUMER - PR #$PR_NUM"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 2: Get PR state
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          PR_DATA=$(gh pr view $PR_NUM --json isDraft,mergeable,reviewDecision,title,labels 2>/dev/null || echo "{}")
          
          IS_DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft // false')
          MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable // "UNKNOWN"')
          REVIEW=$(echo "$PR_DATA" | jq -r '.reviewDecision // "REVIEW_REQUIRED"')
          TITLE=$(echo "$PR_DATA" | jq -r '.title // "Unknown"')
          HAS_AUTO=$(echo "$PR_DATA" | jq '[.labels[]?.name // empty] | map(select(. == "auto-merge")) | length')
          
          echo ""
          echo "üìã PR State: $TITLE"
          echo "   Draft: $IS_DRAFT | Mergeable: $MERGEABLE | Review: $REVIEW"
          
          [ "$IS_DRAFT" = "true" ] && echo "‚è∏Ô∏è  Draft PR - skipping" && exit 0
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 3: Read the FIXED POINT (feedback queue state)
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "üìñ Reading feedback queue (fixed point)..."
          
          QUEUE_MARKER="CASCADE Review Synthesis"
          QUEUE_STATE=$(gh api repos/${{ github.repository }}/issues/$PR_NUM/comments --jq "
            [.[] | select(.body | contains(\"$QUEUE_MARKER\"))] | last | .body // empty
          " 2>/dev/null || echo "")
          
          # Parse queue state
          CRITICAL=0
          IMPORTANT=0
          SUGGESTED=0
          VERDICT="CLEAR"
          
          if [ -n "$QUEUE_STATE" ]; then
            echo "   ‚úÖ Queue has state"
            
            # Count severity markers
            CRITICAL=$(echo "$QUEUE_STATE" | grep -c "üî¥" || echo "0")
            IMPORTANT=$(echo "$QUEUE_STATE" | grep -c "üü†" || echo "0")
            SUGGESTED=$(echo "$QUEUE_STATE" | grep -c "üü°" || echo "0")
            
            echo "   üî¥ Critical: $CRITICAL | üü† Important: $IMPORTANT | üü° Suggested: $SUGGESTED"
            
            # Determine verdict from queue
            if [ "$CRITICAL" -gt 0 ]; then
              VERDICT="BLOCKED"
            elif echo "$QUEUE_STATE" | grep -qi "verdict.*ready\|ready.*merge\|‚úÖ.*merge"; then
              VERDICT="READY"
            elif [ "$IMPORTANT" -gt 0 ]; then
              VERDICT="REVIEW"
            else
              VERDICT="CLEAR"
            fi
          else
            echo "   ‚ö™ Queue empty (no AI feedback yet)"
            VERDICT="CLEAR"  # No feedback = no blockers
          fi
          
          echo "   üìä Queue verdict: $VERDICT"
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 4: Check CI status
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "üî¨ Checking CI pipeline..."
          
          FAILED=$(gh pr checks $PR_NUM --json conclusion --jq '[.[] | select(.conclusion == "FAILURE" or .conclusion == "TIMED_OUT")] | length' 2>/dev/null || echo "0")
          PENDING=$(gh pr checks $PR_NUM --json state --jq '[.[] | select(.state == "PENDING" or .state == "QUEUED")] | length' 2>/dev/null || echo "0")
          
          echo "   Failed: $FAILED | Pending: $PENDING"
          
          CI_READY=false
          [ "$FAILED" -eq 0 ] && [ "$PENDING" -eq 0 ] && CI_READY=true
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 5: DECISION MATRIX
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
          echo "‚îÇ                   DECISION MATRIX                       ‚îÇ"
          echo "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"
          printf "‚îÇ %-21s ‚îÇ %-31s ‚îÇ\n" "CI Pipeline" "$([ "$CI_READY" = true ] && echo '‚úÖ All checks passed' || echo "‚ùå $FAILED failed, $PENDING pending")"
          printf "‚îÇ %-21s ‚îÇ %-31s ‚îÇ\n" "Mergeable State" "$([ "$MERGEABLE" = 'MERGEABLE' ] && echo '‚úÖ Ready' || echo "‚ùå $MERGEABLE")"
          printf "‚îÇ %-21s ‚îÇ %-31s ‚îÇ\n" "Critical Issues" "$([ "$CRITICAL" -eq 0 ] && echo '‚úÖ None' || echo "üî¥ $CRITICAL blocking")"
          printf "‚îÇ %-21s ‚îÇ %-31s ‚îÇ\n" "Queue Verdict" "$VERDICT"
          echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
          
          # Decision logic
          CAN_MERGE=false
          REASON=""
          
          if [ "$CI_READY" = true ] && [ "$MERGEABLE" = "MERGEABLE" ] && [ "$CRITICAL" -eq 0 ]; then
            case "$VERDICT" in
              READY|CLEAR)
                CAN_MERGE=true
                REASON="CI ‚úÖ + Mergeable ‚úÖ + Queue clear"
                ;;
              REVIEW)
                # Important issues exist but not critical - can still merge
                CAN_MERGE=true
                REASON="CI ‚úÖ + Mergeable ‚úÖ + Non-blocking feedback ($IMPORTANT items)"
                ;;
              BLOCKED)
                REASON="Queue blocked by critical issues"
                ;;
            esac
          elif [ "$CI_READY" = false ]; then
            REASON="CI pipeline not ready"
          elif [ "$MERGEABLE" != "MERGEABLE" ]; then
            REASON="PR not in mergeable state ($MERGEABLE)"
          elif [ "$CRITICAL" -gt 0 ]; then
            REASON="$CRITICAL critical issues in queue"
          fi
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # STEP 6: ACT on decision
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          echo ""
          if [ "$CAN_MERGE" = true ]; then
            echo "‚úÖ ELIGIBLE FOR AUTO-MERGE"
            echo "   Reason: $REASON"
            
            # Ensure label exists
            gh label create "auto-merge" --description "Eligible for automatic merging" --color "0E8A16" 2>/dev/null || true
            
            # Add label if not present
            if [ "$HAS_AUTO" -eq 0 ]; then
              gh pr edit $PR_NUM --add-label "auto-merge"
              echo "   üìå Added auto-merge label"
            fi
            
            # Auto-approve if needed
            if [ "$REVIEW" != "APPROVED" ]; then
              APPROVE_MSG="‚úÖ **Auto-approved by Merge Queue Consumer**

          | Check | Status |
          |-------|--------|
          | CI Pipeline | ‚úÖ Passed |
          | Mergeable | ‚úÖ Ready |
          | Queue State | $VERDICT |
          | Critical Issues | $CRITICAL |

          **Reason:** $REASON"
              
              gh pr review $PR_NUM --approve --body "$APPROVE_MSG" 2>/dev/null || echo "   ‚ö†Ô∏è  Could not auto-approve"
              echo "   ‚úÖ Approved PR"
            fi
            
            echo ""
            echo "üöÄ PR #$PR_NUM is queued for merge"
          else
            echo "‚è∏Ô∏è  NOT ELIGIBLE FOR AUTO-MERGE"
            echo "   Reason: $REASON"
            
            # Remove auto-merge label if present and now ineligible
            if [ "$HAS_AUTO" -gt 0 ]; then
              gh pr edit $PR_NUM --remove-label "auto-merge" 2>/dev/null || true
              echo "   üè∑Ô∏è  Removed auto-merge label"
            fi
          fi
