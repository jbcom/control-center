# Ecosystem Connector - Unified @cascade AI Automation
# Single trigger point for cost-optimized AI routing
# All actions pinned to exact SHAs for security and reproducibility
#
# PRIME DIRECTIVES (Enterprise Standards):
# 1. SHA Pinning - All GitHub Actions must use exact commit SHAs
# 2. Token Standards - Use CI_GITHUB_TOKEN pattern consistently
# 3. Conventional Commits - PR titles must follow conventional commit format
# 4. Security Scanning - No hardcoded secrets or tokens in code
# 5. Required Files - Repos must have CLAUDE.md and AGENTS.md
# 6. Permissions - Workflows must declare minimum required permissions

name: Ecosystem Connector

on:
  # PR events - comprehensive triggers for self-assessment
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request
  pull_request:
    types: 
      - opened           # New PR created
      - synchronize      # New commits pushed
      - reopened         # PR reopened after close
      - ready_for_review # Draft -> Ready
      - labeled          # Label added (for sync/auto-merge)
      - unlabeled        # Label removed
  pull_request_review:
    types: [submitted, dismissed]
  # For @cascade commands in PR comments
  issue_comment:
    types: [created]
  # For CI completion -> self-assess
  check_suite:
    types: [completed]
  # Check runs for more granular CI status
  check_run:
    types: [completed]
  # Status updates (external CI systems)
  status: {}
  # Main branch - propagate changes, no reviews
  push:
    branches: [main]
    paths:
      - '.github/workflows/ecosystem-connector.yml'
      - 'repository-files/always-sync/**'

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

concurrency:
  group: ecosystem-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

env:
  # Comment deduplication - check for existing comments before posting
  # Each job should check: gh pr view $PR --json comments --jq '.comments[] | select(.body | contains("MARKER")) | .id' | head -1
  COMMENT_COOLDOWN_MINUTES: 5

jobs:
  # ============================================================
  # MAIN BRANCH: Propagate ecosystem-connector changes
  # ============================================================
  propagate-on-main:
    name: Propagate to Ecosystem
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Trigger ecosystem sync
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          echo "๐ ecosystem-connector updated on main - triggering sync..."
          
          # Trigger the ecosystem-sync workflow
          gh workflow run ecosystem-sync.yml --repo ${{ github.repository }} || echo "Sync workflow triggered or already running"
          
          echo "โ Sync triggered - changes will propagate to all org control-centers"

  # ============================================================
  # PRIME DIRECTIVE: Enforce SHA pinning for GitHub Actions
  # ============================================================
  pin-actions:
    name: Pin Actions
    if: github.event_name == 'pull_request' && !github.event.pull_request.draft
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Check for workflow changes
        id: check
        run: |
          # Check if PR contains workflow files
          WORKFLOW_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD -- '.github/workflows/*.yml' '.github/workflows/*.yaml' 2>/dev/null || echo "")
          
          if [ -z "$WORKFLOW_FILES" ]; then
            echo "No workflow files changed"
            echo "has_workflows=false" >> $GITHUB_OUTPUT
          else
            echo "Workflow files changed:"
            echo "$WORKFLOW_FILES"
            echo "has_workflows=true" >> $GITHUB_OUTPUT
            echo "$WORKFLOW_FILES" > /tmp/workflow_files.txt
          fi

      - name: Enforce SHA pinning
        if: steps.check.outputs.has_workflows == 'true'
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # Known latest action SHAs (update periodically)
          declare -A ACTION_SHAS
          ACTION_SHAS["actions/checkout"]="8e8c483db84b4bee98b60c0593521ed34d9990e8|v6.0.1"
          ACTION_SHAS["actions/setup-node"]="49933ea5288caeca8642d1e84afbd3f7d6820020|v4.4.0"
          ACTION_SHAS["actions/setup-python"]="a26af69be951a213d495a4c3e4e4022e16d87065|v5.6.0"
          ACTION_SHAS["actions/cache"]="5a3ec84eff668545956fd18022155c47e93e2684|v4.2.3"
          ACTION_SHAS["actions/upload-artifact"]="ea165f8d65b6e75b540449e92b4886f43607fa02|v4.6.2"
          ACTION_SHAS["actions/download-artifact"]="fa0a91b85d4f404e444e00e005971372dc801d16|v4.1.8"
          ACTION_SHAS["github/codeql-action/init"]="fca7ace96b7d713c7035871441bd52efbe39e27e|v3.28.19"
          ACTION_SHAS["github/codeql-action/analyze"]="fca7ace96b7d713c7035871441bd52efbe39e27e|v3.28.19"
          ACTION_SHAS["github/codeql-action/autobuild"]="fca7ace96b7d713c7035871441bd52efbe39e27e|v3.28.19"
          ACTION_SHAS["peter-evans/create-pull-request"]="271a8d0340265f705b14b6f32688f5d79ebeba24|v7.0.8"
          ACTION_SHAS["anthropics/claude-code-action"]="154d0de144ff82240e1c3deedff56280381fd122|beta"
          
          VIOLATIONS=""
          FIXES=""
          
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            [ ! -f "$file" ] && continue
            
            echo "Checking $file..."
            
            # Find uses: lines with version tags (not SHAs)
            while IFS= read -r line; do
              [ -z "$line" ] && continue
              
              # Extract action reference (e.g., actions/checkout@v4)
              ACTION=$(echo "$line" | grep -oP 'uses:\s*\K[^@]+' || echo "")
              VERSION=$(echo "$line" | grep -oP '@\K[^\s#]+' || echo "")
              
              [ -z "$ACTION" ] && continue
              
              # Skip if already a SHA (40 hex chars)
              if [[ "$VERSION" =~ ^[a-f0-9]{40}$ ]]; then
                echo "  โ $ACTION@$VERSION (already pinned)"
                continue
              fi
              
              # Check if we have a known SHA for this action
              if [[ -n "${ACTION_SHAS[$ACTION]}" ]]; then
                SHA_VER="${ACTION_SHAS[$ACTION]}"
                SHA="${SHA_VER%%|*}"
                VER="${SHA_VER##*|}"
                
                VIOLATIONS="$VIOLATIONS\n- \`$ACTION@$VERSION\` should be \`$ACTION@$SHA # $VER\`"
                FIXES="$FIXES\n  sed -i 's|$ACTION@$VERSION|$ACTION@$SHA # $VER|g' $file"
              else
                # Unknown action - just flag it
                VIOLATIONS="$VIOLATIONS\n- \`$ACTION@$VERSION\` should be pinned to exact SHA"
              fi
              
            done < <(grep -E '^\s*-?\s*uses:' "$file" 2>/dev/null || true)
            
          done < /tmp/workflow_files.txt
          
          if [ -n "$VIOLATIONS" ]; then
            PR_NUM=${{ github.event.pull_request.number }}
            MARKER="Prime Directive: Pin GitHub Actions"
            
            # Check for existing comment (dedup)
            EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | head -1)
            if [ -n "$EXISTING" ]; then
              echo "Pin actions comment already exists, skipping"
              exit 0
            fi
            
            BODY="## ๐ **$MARKER to SHAs**
          
          The following actions need to be pinned to exact commit SHAs for security and reproducibility:
          $(echo -e "$VIOLATIONS")
          
          ### Why?
          - **Security**: Tag references can be moved, SHAs cannot
          - **Reproducibility**: Exact same code runs every time
          - **Audit trail**: Know exactly what code executed
          
          ### Quick Fix
          \`\`\`bash$(echo -e "$FIXES")
          \`\`\`
          
          ---
          *Use \`@cascade pin these actions\` for automatic fixing*"
            
            gh pr comment $PR_NUM --body "$BODY"
            
            echo "::warning::Workflow files contain unpinned action references"
          else
            echo "โ All actions are properly pinned to SHAs"
          fi

  # ============================================================
  # REVIEW SYNTHESIS: Gather โ Resolve โ Synthesize (One Clean Pass)
  # 1. Fetch ALL AI feedback (reviews, threads, comments)
  # 2. Resolve ALL outdated threads, minimize stale comments
  # 3. Create ONE aggregate synthesis for CASCADE to process
  # ============================================================
  review-synthesis:
    name: Review Synthesis
    if: |
      github.event_name == 'pull_request_review' ||
      github.event_name == 'pull_request' ||
      (github.event_name == 'issue_comment' && 
       contains(github.event.comment.body, '@cascade synthesize'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Gather, Resolve, Synthesize
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          OLLAMA_API_URL: ${{ vars.OLLAMA_API_URL || 'https://api.ollama.com' }}
        run: |
          # Get PR number from various event types
          case "${{ github.event_name }}" in
            issue_comment) PR_NUM="${{ github.event.issue.number }}" ;;
            *) PR_NUM="${{ github.event.pull_request.number }}" ;;
          esac
          
          [ -z "$PR_NUM" ] && echo "No PR number" && exit 0
          
          echo "๐ Gather โ Resolve โ Synthesize for PR #$PR_NUM"
          
          OWNER="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          AI_AGENTS="copilot|github-actions|coderabbitai|gemini|cursor|amazon-q|dependabot|bugbot|claude|sonarcloud|codacy|snyk"
          
          # ============================================================
          # STEP 1: GATHER all AI feedback
          # ============================================================
          echo ""
          echo "๐ฅ Step 1: Gathering all AI feedback..."
          
          QUERY='query($owner: String!, $repo: String!, $pr: Int!) {
            repository(owner: $owner, name: $repo) {
              pullRequest(number: $pr) {
                reviews(first: 100) {
                  nodes {
                    id
                    author { login }
                    body
                    state
                    submittedAt
                  }
                }
                reviewThreads(first: 100) {
                  nodes {
                    id
                    isResolved
                    isOutdated
                    path
                    line
                    comments(first: 10) {
                      nodes {
                        id
                        author { login }
                        body
                        diffHunk
                        createdAt
                      }
                    }
                  }
                }
              }
            }
          }'
          
          RESULT=$(gh api graphql -f query="$QUERY" -f owner="$OWNER" -f repo="$REPO" -F pr="$PR_NUM" 2>/dev/null || echo "{}")
          
          # Extract reviews from AI agents
          REVIEWS=$(echo "$RESULT" | jq -r --arg agents "$AI_AGENTS" '
            [.data.repository.pullRequest.reviews.nodes[]? |
            select(.author.login | test($agents; "i")) |
            {author: .author.login, state: .state, body: .body, date: .submittedAt}]
          ' 2>/dev/null || echo "[]")
          
          # Extract unresolved threads from AI agents
          THREADS=$(echo "$RESULT" | jq -r --arg agents "$AI_AGENTS" '
            [.data.repository.pullRequest.reviewThreads.nodes[]? |
            select(.isResolved == false) |
            select(.comments.nodes[0].author.login | test($agents; "i")) |
            {id: .id, path: .path, line: .line, outdated: .isOutdated,
             author: .comments.nodes[0].author.login,
             body: .comments.nodes[0].body,
             diffHunk: .comments.nodes[0].diffHunk}]
          ' 2>/dev/null || echo "[]")
          
          # Extract outdated thread IDs for resolution
          OUTDATED_IDS=$(echo "$RESULT" | jq -r --arg agents "$AI_AGENTS" '
            .data.repository.pullRequest.reviewThreads.nodes[]? |
            select(.isOutdated == true and .isResolved == false) |
            select(.comments.nodes[0].author.login | test($agents; "i")) |
            .id
          ' 2>/dev/null || echo "")
          
          REVIEW_COUNT=$(echo "$REVIEWS" | jq 'length')
          THREAD_COUNT=$(echo "$THREADS" | jq 'length')
          OUTDATED_COUNT=$(echo "$OUTDATED_IDS" | grep -c . || echo "0")
          
          echo "  Found: $REVIEW_COUNT reviews, $THREAD_COUNT active threads, $OUTDATED_COUNT outdated"
          
          # ============================================================
          # STEP 2: RESOLVE all outdated threads
          # ============================================================
          echo ""
          echo "๐งน Step 2: Resolving outdated threads..."
          
          RESOLVED=0
          for THREAD_ID in $OUTDATED_IDS; do
            [ -z "$THREAD_ID" ] && continue
            gh api graphql -f query='mutation($id: ID!) {
              resolveReviewThread(input: {threadId: $id}) {
                thread { isResolved }
              }
            }' -f id="$THREAD_ID" 2>/dev/null && RESOLVED=$((RESOLVED + 1))
          done
          echo "  โ Resolved $RESOLVED outdated threads"
          
          # Minimize old bot comments (keep last 3)
          BOT_COMMENTS=$(gh api repos/${{ github.repository }}/issues/$PR_NUM/comments --jq '
            [.[] | select(.user.type == "Bot" or (.user.login | test("copilot|coderabbit|gemini|amazon-q|cursor|bugbot|sonar|snyk|codacy"; "i"))) | .node_id]
          ' 2>/dev/null || echo "[]")
          
          COMMENT_COUNT=$(echo "$BOT_COMMENTS" | jq 'length')
          if [ "$COMMENT_COUNT" -gt 5 ]; then
            echo "  Minimizing old bot comments ($COMMENT_COUNT total, keeping last 3)..."
            echo "$BOT_COMMENTS" | jq -r '.[:(-3)][]' | while read -r CID; do
              [ -z "$CID" ] && continue
              gh api graphql -f query='mutation($id: ID!) {
                minimizeComment(input: {subjectId: $id, classifier: OUTDATED}) {
                  minimizedComment { isMinimized }
                }
              }' -f id="$CID" 2>/dev/null || true
            done
            echo "  โ Minimized old comments"
          fi
          
          # ============================================================
          # STEP 3: SYNTHESIZE into ONE aggregate comment
          # ============================================================
          echo ""
          echo "๐ฌ Step 3: Creating synthesis..."
          
          # Skip if nothing to synthesize
          if [ "$REVIEW_COUNT" -eq 0 ] && [ "$THREAD_COUNT" -eq 0 ]; then
            echo "  No AI feedback to synthesize"
            exit 0
          fi
          
          # Build context for synthesis
          REVIEW_TEXT=$(echo "$REVIEWS" | jq -r '.[] | "**\(.author)** (\(.state)): \(.body)"' 2>/dev/null | head -50)
          THREAD_TEXT=$(echo "$THREADS" | jq -r '.[] | "**\(.author)** on `\(.path):\(.line // "?")`: \(.body)"' 2>/dev/null | head -50)
          
          CONTEXT="Synthesize this AI feedback for a PR:

          ## Reviews ($REVIEW_COUNT)
          $REVIEW_TEXT

          ## Active Suggestions ($THREAD_COUNT)  
          $THREAD_TEXT

          Create a concise actionable summary:
          1. ๐ด **Critical** - Must fix (security, bugs)
          2. ๐ **Important** - Should fix (performance, logic)
          3. ๐ก **Suggested** - Nice to have (style, clarity)
          4. โ **Already Good** - Positive feedback
          5. ๐ **Verdict** - Ready to merge? What's blocking?"
          
          # Call Ollama for AI synthesis
          SYNTHESIS=""
          if [ -n "$OLLAMA_API_KEY" ] && [ -n "$OLLAMA_API_URL" ]; then
            SYNTHESIS=$(curl -sf --max-time 60 \
              -H "Authorization: Bearer $OLLAMA_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$(jq -n --arg prompt "$CONTEXT" '{
                model: "glm-4.6:cloud",
                messages: [
                  {role: "system", content: "Expert code reviewer. Be concise."},
                  {role: "user", content: $prompt}
                ],
                stream: false
              }')" \
              "$OLLAMA_API_URL/api/chat" 2>/dev/null | jq -r '.message.content // empty') || true
          fi
          
          # Build the ONE aggregate comment
          MARKER="CASCADE Review Synthesis"
          
          if [ -n "$SYNTHESIS" ]; then
            BODY="## ๐ฌ $MARKER

          **Analyzed:** $REVIEW_COUNT reviews, $THREAD_COUNT suggestions | **Resolved:** $RESOLVED outdated

          $SYNTHESIS

          ---
          <sub>๐ค Synthesized by CASCADE | Use \`@cascade address feedback\` to auto-fix</sub>"
          else
            BODY="## ๐ฌ $MARKER

          **Analyzed:** $REVIEW_COUNT reviews, $THREAD_COUNT suggestions | **Resolved:** $RESOLVED outdated

          ### Active Feedback
          $THREAD_TEXT

          ---
          <sub>๐ค Use \`@cascade synthesize\` for AI-powered summary</sub>"
          fi
          
          # Find and UPDATE existing synthesis, or create new
          EXISTING_ID=$(gh api repos/${{ github.repository }}/issues/$PR_NUM/comments --jq "
            .[] | select(.body | contains(\"$MARKER\")) | .node_id
          " 2>/dev/null | tail -1)
          
          if [ -n "$EXISTING_ID" ]; then
            echo "  Updating existing synthesis comment..."
            gh api graphql -f query='mutation($id: ID!, $body: String!) {
              updateIssueComment(input: {id: $id, body: $body}) { clientMutationId }
            }' -f id="$EXISTING_ID" -f body="$BODY" 2>/dev/null || gh pr comment $PR_NUM --body "$BODY"
          else
            echo "  Creating new synthesis comment..."
            gh pr comment $PR_NUM --body "$BODY"
          fi
          
          echo ""
          echo "โ Synthesis complete - ONE aggregate comment for CASCADE"

  # Automatic AI review on new/updated PRs
  auto-review:
    name: Auto Review
    if: github.event_name == 'pull_request' && !github.event.pull_request.draft
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: AI Review
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          MARKER="Cascade Auto-Review"
          
          # Check for existing review comment (dedup)
          EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | head -1)
          if [ -n "$EXISTING" ]; then
            echo "Review comment already exists, skipping"
            exit 0
          fi
          
          DIFF=$(git diff origin/${{ github.event.pull_request.base.ref }}...HEAD -- '*.py' '*.ts' '*.js' '*.tsx' '*.jsx' '*.go' '*.rs' | head -3000)
          
          if [ -z "$DIFF" ]; then
            echo "No code changes to review"
            exit 0
          fi
          
          gh pr comment $PR_NUM --body "๐ค **$MARKER**
          
          Analyzing PR changes..."

  # Unified @cascade trigger - routes to optimal AI agent
  cascade:
    name: Cascade
    if: |
      github.event_name == 'issue_comment' &&
      contains(github.event.comment.body, '@cascade') &&
      !contains(github.event.comment.body, '@cascade rebase') &&
      !contains(github.event.comment.body, '@cascade synthesize')
    runs-on: ubuntu-latest
    outputs:
      route: ${{ steps.route.outputs.agent }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Route to optimal agent
        id: route
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          echo "๐ Cascade routing..."
          
          # Extract task from comment
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          # Determine optimal agent based on task keywords
          AGENT="claude"  # Default to Claude for most tasks
          
          # Quick questions/explanations -> Ollama (cheapest)
          if echo "$TASK" | grep -qiE "(explain|what is|how does|why|describe|summarize|question)"; then
            AGENT="ollama"
          fi
          
          # Multi-file refactors, large changes -> Jules
          if echo "$TASK" | grep -qiE "(refactor|rename across|update all|migrate|bulk|across files|multi-file)"; then
            AGENT="jules"
          fi
          
          # Long-running, complex debugging -> Cursor
          if echo "$TASK" | grep -qiE "(debug|investigate|long|complex|deep dive|root cause|trace)"; then
            AGENT="cursor"
          fi
          
          # Merge conflicts, rebase -> Claude (can handle git)
          if echo "$TASK" | grep -qiE "(rebase|merge|conflict|resolve|sync with main)"; then
            AGENT="claude"
          fi
          
          # Code review, fix issues -> Claude
          if echo "$TASK" | grep -qiE "(review|fix|address feedback|implement|add|update|change)"; then
            AGENT="claude"
          fi
          
          echo "agent=$AGENT" >> $GITHUB_OUTPUT
          echo "Selected agent: $AGENT"
          
          # Post acknowledgment (no dedup needed - user explicitly triggered)
          echo "agent=$AGENT" >> $GITHUB_OUTPUT
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "๐ **Cascade** โ **$AGENT**: $TASK"
          else
            gh issue comment $ISSUE_NUM --body "๐ **Cascade** โ **$AGENT**: $TASK"
          fi

  # Route: Claude (default for most tasks)
  cascade-claude:
    name: Claude
    needs: cascade
    if: needs.cascade.outputs.route == 'claude'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - uses: anthropics/claude-code-action@154d0de144ff82240e1c3deedff56280381fd122 # latest
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.CI_GITHUB_TOKEN }}
          allowed_bots: '*'
          trigger_phrase: '@cascade'

  # Route: Ollama (cheapest - for quick questions)
  cascade-ollama:
    name: Ollama
    needs: cascade
    if: needs.cascade.outputs.route == 'ollama'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Query Ollama
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          OLLAMA_API_URL: ${{ vars.OLLAMA_API_URL || 'https://api.ollama.com' }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          ISSUE_NUM="${{ github.event.issue.number }}"
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          
          # Simple acknowledgment (Ollama API integration would go here)
          RESPONSE="๐ค **Ollama Response**
          
          Processing: $TASK
          
          _(Cost-optimized quick response)_"
          
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "$RESPONSE"
          else
            gh issue comment $ISSUE_NUM --body "$RESPONSE"
          fi

  # Route: Jules (for multi-file refactors)
  cascade-jules:
    name: Jules
    needs: cascade
    if: needs.cascade.outputs.route == 'jules'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Delegate to Jules
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          GOOGLE_JULES_API_KEY: ${{ secrets.GOOGLE_JULES_API_KEY }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          ISSUE_NUM="${{ github.event.issue.number }}"
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          
          RESPONSE="๐ค **Jules Session**
          
          Task: $TASK
          
          Jules will create a session for multi-file refactoring.
          _(Optimized for large-scale changes)_"
          
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "$RESPONSE"
          else
            gh issue comment $ISSUE_NUM --body "$RESPONSE"
          fi

  # Route: Cursor (for long-running complex tasks)
  cascade-cursor:
    name: Cursor
    needs: cascade
    if: needs.cascade.outputs.route == 'cursor'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Delegate to Cursor
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          ISSUE_NUM="${{ github.event.issue.number }}"
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          
          RESPONSE="๐ค **Cursor Agent**
          
          Task: $TASK
          
          Cursor background agent spawned for deep investigation.
          _(Optimized for complex debugging)_"
          
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "$RESPONSE"
          else
            gh issue comment $ISSUE_NUM --body "$RESPONSE"
          fi

  # Legacy support: direct @claude still works
  claude-direct:
    name: Claude (Direct)
    if: |
      github.event_name == 'issue_comment' &&
      contains(github.event.comment.body, '@claude') &&
      !contains(github.event.comment.body, '@cascade')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - uses: anthropics/claude-code-action@154d0de144ff82240e1c3deedff56280381fd122 # latest
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.CI_GITHUB_TOKEN }}
          allowed_bots: '*'

  # ============================================================
  # CI-FIX: Attempt to fix CI failures
  # ============================================================
  ci-fix:
    name: CI Fix
    if: |
      github.event_name == 'check_suite' &&
      github.event.check_suite.conclusion == 'failure' &&
      github.event.check_suite.pull_requests[0] != null
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}
          ref: ${{ github.event.check_suite.head_branch }}

      - name: Analyze and suggest fix
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=$(echo '${{ toJson(github.event.check_suite.pull_requests) }}' | jq -r '.[0].number')
          
          if [ "$PR_NUM" = "null" ] || [ -z "$PR_NUM" ]; then
            echo "No PR associated with this check suite"
            exit 0
          fi
          
          # Get failed check runs
          FAILED=$(gh api repos/${{ github.repository }}/check-suites/${{ github.event.check_suite.id }}/check-runs \
            --jq '.check_runs[] | select(.conclusion == "failure") | .name' | head -5)
          
          # Check for recent CI failure comment (within last 3 comments)
          MARKER="CI Failure Detected"
          RECENT=$(gh pr view $PR_NUM --json comments --jq ".comments[-3:] | .[] | select(.body | contains(\"$MARKER\")) | .id" | head -1)
          if [ -n "$RECENT" ]; then
            echo "Recent CI failure comment exists, skipping"
            exit 0
          fi
          
          gh pr comment $PR_NUM --body "โ **$MARKER**

          Failed checks:
          \`\`\`
          $FAILED
          \`\`\`

          Use \`@cascade fix the CI failures\` for AI-assisted debugging."

  # ============================================================
  # AUTO-MERGE: Merge when ready
  # ============================================================
  auto-merge:
    name: Auto Merge
    if: |
      github.event_name == 'pull_request_review' &&
      github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - name: Check and merge
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          
          # Check if auto-merge label exists
          HAS_AUTO=$(gh pr view $PR_NUM --json labels --jq '.labels[].name' | grep -c "auto-merge" || true)
          
          if [ "$HAS_AUTO" -eq 0 ]; then
            echo "No auto-merge label, skipping"
            exit 0
          fi
          
          # Check all status checks
          STATUS=$(gh pr checks $PR_NUM --json state --jq '.[] | select(.state != "SUCCESS" and .state != "SKIPPED") | .state' | head -1)
          
          if [ -n "$STATUS" ]; then
            echo "Checks not all passing, waiting..."
            exit 0
          fi
          
          # Merge
          gh pr merge $PR_NUM --squash --delete-branch --body "Auto-merged after approval"
          
          echo "โ PR #$PR_NUM merged"

  # ============================================================
  # SYNC-TRIAGE: Handle sync PRs from control center
  # ============================================================
  sync-triage:
    name: Sync Triage
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'opened' &&
      contains(github.event.pull_request.title, 'sync:')
    runs-on: ubuntu-latest
    steps:
      - name: Auto-approve sync PRs
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          
          # Mark ready for review if draft
          if [ "${{ github.event.pull_request.draft }}" = "true" ]; then
            echo "Converting draft to ready for review..."
            gh pr ready $PR_NUM || true
          fi
          
          # Add label for tracking
          gh pr edit $PR_NUM --add-label "sync,auto-merge"
          
          # Approve if from trusted source
          AUTHOR="${{ github.event.pull_request.user.login }}"
          
          if [[ "$AUTHOR" == *"[bot]"* ]] || [ "$AUTHOR" = "jbcom" ]; then
            gh pr review $PR_NUM --approve --body "โ Approved: Sync from control center"
          fi

  # ============================================================
  # AUTO-REBASE: Rebase PRs with merge conflicts
  # ============================================================
  auto-rebase:
    name: Auto Rebase
    if: |
      (github.event_name == 'pull_request' &&
       (github.event.action == 'synchronize' || github.event.action == 'opened')) ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, '@cascade rebase'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Check and rebase if needed
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # Get PR info
          if [ "${{ github.event_name }}" = "issue_comment" ]; then
            PR_NUM="${{ github.event.issue.number }}"
            # Verify it's a PR, not an issue
            if [ -z "${{ github.event.issue.pull_request }}" ]; then
              echo "Not a PR, skipping"
              exit 0
            fi
          else
            PR_NUM="${{ github.event.pull_request.number }}"
          fi
          
          # Get PR details
          PR_DATA=$(gh pr view $PR_NUM --json headRefName,baseRefName,mergeable,mergeStateStatus)
          HEAD_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
          BASE_BRANCH=$(echo "$PR_DATA" | jq -r '.baseRefName')
          MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')
          MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus')
          
          echo "PR #$PR_NUM: $HEAD_BRANCH -> $BASE_BRANCH"
          echo "Mergeable: $MERGEABLE, State: $MERGE_STATE"
          
          # Check if rebase is needed
          if [ "$MERGEABLE" = "CONFLICTING" ] || [ "$MERGE_STATE" = "BEHIND" ] || [ "$MERGE_STATE" = "DIRTY" ]; then
            echo "๐ Rebase needed..."
            
            # Configure git
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            # Fetch all branches
            git fetch origin $BASE_BRANCH
            git fetch origin $HEAD_BRANCH
            
            # Checkout the PR branch
            git checkout $HEAD_BRANCH
            
            # Attempt rebase
            if git rebase origin/$BASE_BRANCH; then
              echo "โ Rebase successful"
              
              # Force push with lease
              if git push --force-with-lease origin $HEAD_BRANCH; then
                echo "โ Force push successful"
                # No comment on success - reduces noise
              else
                echo "โ Force push failed"
                # Only comment on failure, check for existing
                MARKER="Auto-Rebase Failed"
                EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | tail -1)
                [ -z "$EXISTING" ] && gh pr comment $PR_NUM --body "โ๏ธ **$MARKER** - Rebase succeeded but force push failed. Please rebase manually."
              fi
            else
              echo "โ Rebase failed - conflicts require manual resolution"
              git rebase --abort 2>/dev/null || true
              
              # Only comment if no recent failure comment
              MARKER="Auto-Rebase Failed"
              EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | tail -1)
              [ -z "$EXISTING" ] && gh pr comment $PR_NUM --body "โ๏ธ **$MARKER** - Conflicts require manual resolution. Use \`@cascade resolve conflicts\` for help."
            fi
          else
            echo "โ No rebase needed - PR is up to date"
          fi

  # ============================================================
  # MERGE-READY: Check if PR is ready to merge and do it
  # ============================================================
  merge-ready:
    name: Merge Ready
    if: |
      (github.event_name == 'check_suite' &&
       github.event.check_suite.conclusion == 'success') ||
      (github.event_name == 'pull_request' &&
       github.event.action == 'synchronize') ||
      (github.event_name == 'pull_request_review' &&
       github.event.review.state == 'approved')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Check and merge eligible PRs
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # Get PR number(s) based on event type
          if [ "${{ github.event_name }}" = "check_suite" ]; then
            PRS='${{ toJson(github.event.check_suite.pull_requests) }}'
            PR_NUMS=$(echo "$PRS" | jq -r '.[].number' 2>/dev/null || echo "")
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_NUMS="${{ github.event.pull_request.number }}"
          elif [ "${{ github.event_name }}" = "pull_request_review" ]; then
            PR_NUMS="${{ github.event.pull_request.number }}"
          else
            PR_NUMS=""
          fi
          
          for PR_NUM in $PR_NUMS; do
            [ -z "$PR_NUM" ] && continue
            [ "$PR_NUM" = "null" ] && continue
            
            echo "Checking PR #$PR_NUM..."
            
            # Get PR details
            PR_DATA=$(gh pr view $PR_NUM --json labels,reviewDecision,mergeable,mergeStateStatus,isDraft)
            
            IS_DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft')
            MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')
            MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus')
            REVIEW=$(echo "$PR_DATA" | jq -r '.reviewDecision')
            HAS_AUTO=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "auto-merge" || echo "0")
            HAS_SYNC=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "sync" || echo "0")
            
            echo "  Draft: $IS_DRAFT, Mergeable: $MERGEABLE, State: $MERGE_STATE"
            echo "  Review: $REVIEW, Auto-merge: $HAS_AUTO, Sync: $HAS_SYNC"
            
            # Skip drafts
            if [ "$IS_DRAFT" = "true" ]; then
              echo "  Skipping - draft PR"
              continue
            fi
            
            # Check if auto-merge eligible
            if [ "$HAS_AUTO" -eq 0 ] && [ "$HAS_SYNC" -eq 0 ]; then
              echo "  Skipping - no auto-merge or sync label"
              continue
            fi
            
            # Check if behind - trigger rebase (but don't spam)
            if [ "$MERGE_STATE" = "BEHIND" ] || [ "$MERGEABLE" = "CONFLICTING" ]; then
              # Check if we already requested rebase recently
              RECENT_REBASE=$(gh pr view $PR_NUM --json comments --jq '.comments[-5:] | .[] | select(.body | contains("@cascade rebase")) | .id' | head -1)
              if [ -z "$RECENT_REBASE" ]; then
                echo "  PR needs rebase, triggering..."
                gh pr comment $PR_NUM --body "@cascade rebase"
              else
                echo "  PR needs rebase but already requested recently"
              fi
              continue
            fi
            
            # Check if ready to merge
            if [ "$MERGEABLE" = "MERGEABLE" ] && [ "$MERGE_STATE" = "CLEAN" ]; then
              # Sync PRs can merge without review approval
              if [ "$HAS_SYNC" -gt 0 ]; then
                echo "  โ Merging sync PR..."
                gh pr merge $PR_NUM --squash --delete-branch --body "Auto-merged: sync from control center" || echo "  Merge failed"
              elif [ "$REVIEW" = "APPROVED" ]; then
                echo "  โ Merging approved PR..."
                gh pr merge $PR_NUM --squash --delete-branch --body "Auto-merged after approval" || echo "  Merge failed"
              else
                echo "  Skipping - awaiting review approval"
              fi
            else
              echo "  Skipping - not in mergeable state"
            fi
          done

  # ============================================================
  # DRAFT-READY: Convert drafts to ready when CI passes
  # ============================================================
  draft-ready:
    name: Draft Ready
    if: |
      github.event_name == 'check_suite' &&
      github.event.check_suite.conclusion == 'success' &&
      github.event.check_suite.pull_requests[0] != null
    runs-on: ubuntu-latest
    steps:
      - name: Mark ready if draft and CI passed
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=$(echo '${{ toJson(github.event.check_suite.pull_requests) }}' | jq -r '.[0].number')
          
          if [ "$PR_NUM" = "null" ] || [ -z "$PR_NUM" ]; then
            exit 0
          fi
          
          # Check if PR is draft
          IS_DRAFT=$(gh pr view $PR_NUM --json isDraft --jq '.isDraft')
          
          if [ "$IS_DRAFT" = "true" ]; then
            echo "CI passed - converting draft PR #$PR_NUM to ready for review"
            gh pr ready $PR_NUM
            # No comment - the ready_for_review event will trigger auto-review
          fi

  # ============================================================
  # MERGE QUEUE CONSUMER: Read fixed point โ Evaluate โ Decide
  # ============================================================
  # Pattern: Feedback Merge Queue
  #   PRODUCERS: AI reviewers (Copilot, Gemini, CodeRabbit, etc.)
  #   QUEUE: Fixed-point synthesis comment (updated by review-synthesis)
  #   CONSUMER: This job - reads queue state, decides on merge
  #
  # Division of labor (backportable to @agentic packages):
  #   review-synthesis = @agentic/triage (primitives)
  #   merge-assess = @agentic/control (decisions)
  # ============================================================
  merge-assess:
    name: Merge Queue Consumer
    needs: [review-synthesis]
    if: always()  # Run even if synthesis skipped (no feedback yet = OK to merge)
    runs-on: ubuntu-latest
    steps:
      - name: Consume queue and assess merge eligibility
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          # STEP 1: Resolve PR number from event
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          case "${{ github.event_name }}" in
            pull_request) PR_NUM="${{ github.event.pull_request.number }}" ;;
            pull_request_review) PR_NUM="${{ github.event.pull_request.number }}" ;;
            issue_comment) PR_NUM="${{ github.event.issue.number }}" ;;
            check_suite) PR_NUM=$(echo '${{ toJson(github.event.check_suite.pull_requests) }}' | jq -r '.[0].number // empty') ;;
            check_run) PR_NUM=$(echo '${{ toJson(github.event.check_run.pull_requests) }}' | jq -r '.[0].number // empty') ;;
            status)
              COMMIT="${{ github.event.commit.sha }}"
              PR_NUM=$(gh pr list --state open --json number,headRefOid --jq ".[] | select(.headRefOid == \"$COMMIT\") | .number" 2>/dev/null | head -1)
              ;;
            *) PR_NUM="" ;;
          esac
          
          [ -z "$PR_NUM" ] || [ "$PR_NUM" = "null" ] && echo "No PR context" && exit 0
          
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
          echo "โ  ๐ฏ MERGE QUEUE CONSUMER - PR #$PR_NUM"
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
          
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          # STEP 2: Get PR state
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          PR_DATA=$(gh pr view $PR_NUM --json isDraft,mergeable,reviewDecision,title,labels 2>/dev/null || echo "{}")
          
          IS_DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft // false')
          MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable // "UNKNOWN"')
          REVIEW=$(echo "$PR_DATA" | jq -r '.reviewDecision // "REVIEW_REQUIRED"')
          TITLE=$(echo "$PR_DATA" | jq -r '.title // "Unknown"')
          HAS_AUTO=$(echo "$PR_DATA" | jq '[.labels[]?.name // empty] | map(select(. == "auto-merge")) | length')
          
          echo ""
          echo "๐ PR State: $TITLE"
          echo "   Draft: $IS_DRAFT | Mergeable: $MERGEABLE | Review: $REVIEW"
          
          [ "$IS_DRAFT" = "true" ] && echo "โธ๏ธ  Draft PR - skipping" && exit 0
          
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          # STEP 3: Read the FIXED POINT (feedback queue state)
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          echo ""
          echo "๐ Reading feedback queue (fixed point)..."
          
          QUEUE_MARKER="CASCADE Review Synthesis"
          QUEUE_STATE=$(gh api repos/${{ github.repository }}/issues/$PR_NUM/comments --jq "
            [.[] | select(.body | contains(\"$QUEUE_MARKER\"))] | last | .body // empty
          " 2>/dev/null || echo "")
          
          # Parse queue state
          CRITICAL=0
          IMPORTANT=0
          SUGGESTED=0
          VERDICT="CLEAR"
          
          if [ -n "$QUEUE_STATE" ]; then
            echo "   โ Queue has state"
            
            # Count severity markers
            CRITICAL=$(echo "$QUEUE_STATE" | grep -c "๐ด" || echo "0")
            IMPORTANT=$(echo "$QUEUE_STATE" | grep -c "๐" || echo "0")
            SUGGESTED=$(echo "$QUEUE_STATE" | grep -c "๐ก" || echo "0")
            
            echo "   ๐ด Critical: $CRITICAL | ๐ Important: $IMPORTANT | ๐ก Suggested: $SUGGESTED"
            
            # Determine verdict from queue
            if [ "$CRITICAL" -gt 0 ]; then
              VERDICT="BLOCKED"
            elif echo "$QUEUE_STATE" | grep -qi "verdict.*ready\|ready.*merge\|โ.*merge"; then
              VERDICT="READY"
            elif [ "$IMPORTANT" -gt 0 ]; then
              VERDICT="REVIEW"
            else
              VERDICT="CLEAR"
            fi
          else
            echo "   โช Queue empty (no AI feedback yet)"
            VERDICT="CLEAR"  # No feedback = no blockers
          fi
          
          echo "   ๐ Queue verdict: $VERDICT"
          
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          # STEP 4: Check CI status
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          echo ""
          echo "๐ฌ Checking CI pipeline..."
          
          FAILED=$(gh pr checks $PR_NUM --json conclusion --jq '[.[] | select(.conclusion == "FAILURE" or .conclusion == "TIMED_OUT")] | length' 2>/dev/null || echo "0")
          PENDING=$(gh pr checks $PR_NUM --json state --jq '[.[] | select(.state == "PENDING" or .state == "QUEUED")] | length' 2>/dev/null || echo "0")
          
          echo "   Failed: $FAILED | Pending: $PENDING"
          
          CI_READY=false
          [ "$FAILED" -eq 0 ] && [ "$PENDING" -eq 0 ] && CI_READY=true
          
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          # STEP 5: DECISION MATRIX
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          echo ""
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
          echo "โ                   DECISION MATRIX                       โ"
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโค"
          printf "โ %-21s โ %-31s โ\n" "CI Pipeline" "$([ "$CI_READY" = true ] && echo 'โ All checks passed' || echo "โ $FAILED failed, $PENDING pending")"
          printf "โ %-21s โ %-31s โ\n" "Mergeable State" "$([ "$MERGEABLE" = 'MERGEABLE' ] && echo 'โ Ready' || echo "โ $MERGEABLE")"
          printf "โ %-21s โ %-31s โ\n" "Critical Issues" "$([ "$CRITICAL" -eq 0 ] && echo 'โ None' || echo "๐ด $CRITICAL blocking")"
          printf "โ %-21s โ %-31s โ\n" "Queue Verdict" "$VERDICT"
          echo "โโโโโโโโโโโโโโโโโโโโโโโโโดโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
          
          # Decision logic
          CAN_MERGE=false
          REASON=""
          
          if [ "$CI_READY" = true ] && [ "$MERGEABLE" = "MERGEABLE" ] && [ "$CRITICAL" -eq 0 ]; then
            case "$VERDICT" in
              READY|CLEAR)
                CAN_MERGE=true
                REASON="CI โ + Mergeable โ + Queue clear"
                ;;
              REVIEW)
                # Important issues exist but not critical - can still merge
                CAN_MERGE=true
                REASON="CI โ + Mergeable โ + Non-blocking feedback ($IMPORTANT items)"
                ;;
              BLOCKED)
                REASON="Queue blocked by critical issues"
                ;;
            esac
          elif [ "$CI_READY" = false ]; then
            REASON="CI pipeline not ready"
          elif [ "$MERGEABLE" != "MERGEABLE" ]; then
            REASON="PR not in mergeable state ($MERGEABLE)"
          elif [ "$CRITICAL" -gt 0 ]; then
            REASON="$CRITICAL critical issues in queue"
          fi
          
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          # STEP 6: ACT on decision
          # โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          echo ""
          if [ "$CAN_MERGE" = true ]; then
            echo "โ ELIGIBLE FOR AUTO-MERGE"
            echo "   Reason: $REASON"
            
            # Ensure label exists
            gh label create "auto-merge" --description "Eligible for automatic merging" --color "0E8A16" 2>/dev/null || true
            
            # Add label if not present
            if [ "$HAS_AUTO" -eq 0 ]; then
              gh pr edit $PR_NUM --add-label "auto-merge"
              echo "   ๐ Added auto-merge label"
            fi
            
            # Auto-approve if needed
            if [ "$REVIEW" != "APPROVED" ]; then
              APPROVE_MSG="โ **Auto-approved by Merge Queue Consumer**

          | Check | Status |
          |-------|--------|
          | CI Pipeline | โ Passed |
          | Mergeable | โ Ready |
          | Queue State | $VERDICT |
          | Critical Issues | $CRITICAL |

          **Reason:** $REASON"
              
              gh pr review $PR_NUM --approve --body "$APPROVE_MSG" 2>/dev/null || echo "   โ๏ธ  Could not auto-approve"
              echo "   โ Approved PR"
            fi
            
            echo ""
            echo "๐ PR #$PR_NUM is queued for merge"
          else
            echo "โธ๏ธ  NOT ELIGIBLE FOR AUTO-MERGE"
            echo "   Reason: $REASON"
            
            # Remove auto-merge label if present and now ineligible
            if [ "$HAS_AUTO" -gt 0 ]; then
              gh pr edit $PR_NUM --remove-label "auto-merge" 2>/dev/null || true
              echo "   ๐ท๏ธ  Removed auto-merge label"
            fi
          fi
