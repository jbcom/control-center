# Ecosystem Connector - Unified @cascade AI Automation
# Single trigger point for cost-optimized AI routing
# All actions pinned to exact SHAs for security and reproducibility
#
# PRIME DIRECTIVES (Enterprise Standards):
# 1. SHA Pinning - All GitHub Actions must use exact commit SHAs
# 2. Token Standards - Use CI_GITHUB_TOKEN pattern consistently
# 3. Conventional Commits - PR titles must follow conventional commit format
# 4. Security Scanning - No hardcoded secrets or tokens in code
# 5. Required Files - Repos must have CLAUDE.md and AGENTS.md
# 6. Permissions - Workflows must declare minimum required permissions

name: Ecosystem Connector

on:
  # PR events - comprehensive triggers for self-assessment
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request
  pull_request:
    types: 
      - opened           # New PR created
      - synchronize      # New commits pushed
      - reopened         # PR reopened after close
      - ready_for_review # Draft -> Ready
      - labeled          # Label added (for sync/auto-merge)
      - unlabeled        # Label removed
  pull_request_review:
    types: [submitted, dismissed]
  # For @cascade commands in PR comments
  issue_comment:
    types: [created]
  # For CI completion -> self-assess
  check_suite:
    types: [completed]
  # Check runs for more granular CI status
  check_run:
    types: [completed]
  # Status updates (external CI systems)
  status: {}
  # Main branch - propagate changes, no reviews
  push:
    branches: [main]
    paths:
      - '.github/workflows/ecosystem-connector.yml'
      - 'repository-files/always-sync/**'

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

concurrency:
  group: ecosystem-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

env:
  # Comment deduplication - check for existing comments before posting
  # Each job should check: gh pr view $PR --json comments --jq '.comments[] | select(.body | contains("MARKER")) | .id' | head -1
  COMMENT_COOLDOWN_MINUTES: 5

jobs:
  # ============================================================
  # MAIN BRANCH: Propagate ecosystem-connector changes
  # ============================================================
  propagate-on-main:
    name: Propagate to Ecosystem
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Trigger ecosystem sync
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          echo "ðŸš€ ecosystem-connector updated on main - triggering sync..."
          
          # Trigger the ecosystem-sync workflow
          gh workflow run ecosystem-sync.yml --repo ${{ github.repository }} || echo "Sync workflow triggered or already running"
          
          echo "âœ… Sync triggered - changes will propagate to all org control-centers"

  # ============================================================
  # PRIME DIRECTIVE: Enforce SHA pinning for GitHub Actions
  # ============================================================
  pin-actions:
    name: Pin Actions
    if: github.event_name == 'pull_request' && !github.event.pull_request.draft
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Check for workflow changes
        id: check
        run: |
          # Check if PR contains workflow files
          WORKFLOW_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD -- '.github/workflows/*.yml' '.github/workflows/*.yaml' 2>/dev/null || echo "")
          
          if [ -z "$WORKFLOW_FILES" ]; then
            echo "No workflow files changed"
            echo "has_workflows=false" >> $GITHUB_OUTPUT
          else
            echo "Workflow files changed:"
            echo "$WORKFLOW_FILES"
            echo "has_workflows=true" >> $GITHUB_OUTPUT
            echo "$WORKFLOW_FILES" > /tmp/workflow_files.txt
          fi

      - name: Enforce SHA pinning
        if: steps.check.outputs.has_workflows == 'true'
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # Known latest action SHAs (update periodically)
          declare -A ACTION_SHAS
          ACTION_SHAS["actions/checkout"]="8e8c483db84b4bee98b60c0593521ed34d9990e8|v6.0.1"
          ACTION_SHAS["actions/setup-node"]="49933ea5288caeca8642d1e84afbd3f7d6820020|v4.4.0"
          ACTION_SHAS["actions/setup-python"]="a26af69be951a213d495a4c3e4e4022e16d87065|v5.6.0"
          ACTION_SHAS["actions/cache"]="5a3ec84eff668545956fd18022155c47e93e2684|v4.2.3"
          ACTION_SHAS["actions/upload-artifact"]="ea165f8d65b6e75b540449e92b4886f43607fa02|v4.6.2"
          ACTION_SHAS["actions/download-artifact"]="fa0a91b85d4f404e444e00e005971372dc801d16|v4.1.8"
          ACTION_SHAS["github/codeql-action/init"]="fca7ace96b7d713c7035871441bd52efbe39e27e|v3.28.19"
          ACTION_SHAS["github/codeql-action/analyze"]="fca7ace96b7d713c7035871441bd52efbe39e27e|v3.28.19"
          ACTION_SHAS["github/codeql-action/autobuild"]="fca7ace96b7d713c7035871441bd52efbe39e27e|v3.28.19"
          ACTION_SHAS["peter-evans/create-pull-request"]="271a8d0340265f705b14b6f32688f5d79ebeba24|v7.0.8"
          ACTION_SHAS["anthropics/claude-code-action"]="154d0de144ff82240e1c3deedff56280381fd122|beta"
          
          VIOLATIONS=""
          FIXES=""
          
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            [ ! -f "$file" ] && continue
            
            echo "Checking $file..."
            
            # Find uses: lines with version tags (not SHAs)
            while IFS= read -r line; do
              [ -z "$line" ] && continue
              
              # Extract action reference (e.g., actions/checkout@v4)
              ACTION=$(echo "$line" | grep -oP 'uses:\s*\K[^@]+' || echo "")
              VERSION=$(echo "$line" | grep -oP '@\K[^\s#]+' || echo "")
              
              [ -z "$ACTION" ] && continue
              
              # Skip if already a SHA (40 hex chars)
              if [[ "$VERSION" =~ ^[a-f0-9]{40}$ ]]; then
                echo "  âœ… $ACTION@$VERSION (already pinned)"
                continue
              fi
              
              # Check if we have a known SHA for this action
              if [[ -n "${ACTION_SHAS[$ACTION]}" ]]; then
                SHA_VER="${ACTION_SHAS[$ACTION]}"
                SHA="${SHA_VER%%|*}"
                VER="${SHA_VER##*|}"
                
                VIOLATIONS="$VIOLATIONS\n- \`$ACTION@$VERSION\` should be \`$ACTION@$SHA # $VER\`"
                FIXES="$FIXES\n  sed -i 's|$ACTION@$VERSION|$ACTION@$SHA # $VER|g' $file"
              else
                # Unknown action - just flag it
                VIOLATIONS="$VIOLATIONS\n- \`$ACTION@$VERSION\` should be pinned to exact SHA"
              fi
              
            done < <(grep -E '^\s*-?\s*uses:' "$file" 2>/dev/null || true)
            
          done < /tmp/workflow_files.txt
          
          if [ -n "$VIOLATIONS" ]; then
            PR_NUM=${{ github.event.pull_request.number }}
            MARKER="Prime Directive: Pin GitHub Actions"
            
            # Check for existing comment (dedup)
            EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | head -1)
            if [ -n "$EXISTING" ]; then
              echo "Pin actions comment already exists, skipping"
              exit 0
            fi
            
            BODY="## ðŸ”’ **$MARKER to SHAs**
          
          The following actions need to be pinned to exact commit SHAs for security and reproducibility:
          $(echo -e "$VIOLATIONS")
          
          ### Why?
          - **Security**: Tag references can be moved, SHAs cannot
          - **Reproducibility**: Exact same code runs every time
          - **Audit trail**: Know exactly what code executed
          
          ### Quick Fix
          \`\`\`bash$(echo -e "$FIXES")
          \`\`\`
          
          ---
          *Use \`@cascade pin these actions\` for automatic fixing*"
            
            gh pr comment $PR_NUM --body "$BODY"
            
            echo "::warning::Workflow files contain unpinned action references"
          else
            echo "âœ… All actions are properly pinned to SHAs"
          fi

  # ============================================================
  # REVIEW SYNTHESIS: Gather â†’ Resolve â†’ Synthesize (One Clean Pass)
  # 1. Fetch ALL AI feedback (reviews, threads, comments)
  # 2. Resolve ALL outdated threads, minimize stale comments
  # 3. Create ONE aggregate synthesis for CASCADE to process
  # ============================================================
  review-synthesis:
    name: Review Synthesis
    if: |
      github.event_name == 'pull_request_review' ||
      github.event_name == 'pull_request' ||
      (github.event_name == 'issue_comment' && 
       contains(github.event.comment.body, '@cascade synthesize'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Gather, Resolve, Synthesize
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          OLLAMA_API_URL: ${{ vars.OLLAMA_API_URL || 'https://api.ollama.com' }}
        run: |
          # Get PR number from various event types
          case "${{ github.event_name }}" in
            issue_comment) PR_NUM="${{ github.event.issue.number }}" ;;
            *) PR_NUM="${{ github.event.pull_request.number }}" ;;
          esac
          
          [ -z "$PR_NUM" ] && echo "No PR number" && exit 0
          
          echo "ðŸ”„ Gather â†’ Resolve â†’ Synthesize for PR #$PR_NUM"
          
          OWNER="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          AI_AGENTS="copilot|github-actions|coderabbitai|gemini|cursor|amazon-q|dependabot|bugbot|claude|sonarcloud|codacy|snyk"
          
          # ============================================================
          # STEP 1: GATHER all AI feedback
          # ============================================================
          echo ""
          echo "ðŸ“¥ Step 1: Gathering all AI feedback..."
          
          QUERY='query($owner: String!, $repo: String!, $pr: Int!) {
            repository(owner: $owner, name: $repo) {
              pullRequest(number: $pr) {
                reviews(first: 100) {
                  nodes {
                    id
                    author { login }
                    body
                    state
                    submittedAt
                  }
                }
                reviewThreads(first: 100) {
                  nodes {
                    id
                    isResolved
                    isOutdated
                    path
                    line
                    comments(first: 10) {
                      nodes {
                        id
                        author { login }
                        body
                        diffHunk
                        createdAt
                      }
                    }
                  }
                }
              }
            }
          }'
          
          RESULT=$(gh api graphql -f query="$QUERY" -f owner="$OWNER" -f repo="$REPO" -F pr="$PR_NUM" 2>/dev/null || echo "{}")
          
          # Extract reviews from AI agents
          REVIEWS=$(echo "$RESULT" | jq -r --arg agents "$AI_AGENTS" '
            [.data.repository.pullRequest.reviews.nodes[]? |
            select(.author.login | test($agents; "i")) |
            {author: .author.login, state: .state, body: .body, date: .submittedAt}]
          ' 2>/dev/null || echo "[]")
          
          # Extract unresolved threads from AI agents
          THREADS=$(echo "$RESULT" | jq -r --arg agents "$AI_AGENTS" '
            [.data.repository.pullRequest.reviewThreads.nodes[]? |
            select(.isResolved == false) |
            select(.comments.nodes[0].author.login | test($agents; "i")) |
            {id: .id, path: .path, line: .line, outdated: .isOutdated,
             author: .comments.nodes[0].author.login,
             body: .comments.nodes[0].body,
             diffHunk: .comments.nodes[0].diffHunk}]
          ' 2>/dev/null || echo "[]")
          
          # Extract outdated thread IDs for resolution
          OUTDATED_IDS=$(echo "$RESULT" | jq -r --arg agents "$AI_AGENTS" '
            .data.repository.pullRequest.reviewThreads.nodes[]? |
            select(.isOutdated == true and .isResolved == false) |
            select(.comments.nodes[0].author.login | test($agents; "i")) |
            .id
          ' 2>/dev/null || echo "")
          
          REVIEW_COUNT=$(echo "$REVIEWS" | jq 'length')
          THREAD_COUNT=$(echo "$THREADS" | jq 'length')
          OUTDATED_COUNT=$(echo "$OUTDATED_IDS" | grep -c . || echo "0")
          
          echo "  Found: $REVIEW_COUNT reviews, $THREAD_COUNT active threads, $OUTDATED_COUNT outdated"
          
          # ============================================================
          # STEP 2: RESOLVE all outdated threads
          # ============================================================
          echo ""
          echo "ðŸ§¹ Step 2: Resolving outdated threads..."
          
          RESOLVED=0
          for THREAD_ID in $OUTDATED_IDS; do
            [ -z "$THREAD_ID" ] && continue
            gh api graphql -f query='mutation($id: ID!) {
              resolveReviewThread(input: {threadId: $id}) {
                thread { isResolved }
              }
            }' -f id="$THREAD_ID" 2>/dev/null && RESOLVED=$((RESOLVED + 1))
          done
          echo "  âœ… Resolved $RESOLVED outdated threads"
          
          # Minimize old bot comments (keep last 3)
          BOT_COMMENTS=$(gh api repos/${{ github.repository }}/issues/$PR_NUM/comments --jq '
            [.[] | select(.user.type == "Bot" or (.user.login | test("copilot|coderabbit|gemini|amazon-q|cursor|bugbot|sonar|snyk|codacy"; "i"))) | .node_id]
          ' 2>/dev/null || echo "[]")
          
          COMMENT_COUNT=$(echo "$BOT_COMMENTS" | jq 'length')
          if [ "$COMMENT_COUNT" -gt 5 ]; then
            echo "  Minimizing old bot comments ($COMMENT_COUNT total, keeping last 3)..."
            echo "$BOT_COMMENTS" | jq -r '.[:(-3)][]' | while read -r CID; do
              [ -z "$CID" ] && continue
              gh api graphql -f query='mutation($id: ID!) {
                minimizeComment(input: {subjectId: $id, classifier: OUTDATED}) {
                  minimizedComment { isMinimized }
                }
              }' -f id="$CID" 2>/dev/null || true
            done
            echo "  âœ… Minimized old comments"
          fi
          
          # ============================================================
          # STEP 3: SYNTHESIZE into ONE aggregate comment
          # ============================================================
          echo ""
          echo "ðŸ”¬ Step 3: Creating synthesis..."
          
          # Skip if nothing to synthesize
          if [ "$REVIEW_COUNT" -eq 0 ] && [ "$THREAD_COUNT" -eq 0 ]; then
            echo "  No AI feedback to synthesize"
            exit 0
          fi
          
          # Build context for synthesis
          REVIEW_TEXT=$(echo "$REVIEWS" | jq -r '.[] | "**\(.author)** (\(.state)): \(.body)"' 2>/dev/null | head -50)
          THREAD_TEXT=$(echo "$THREADS" | jq -r '.[] | "**\(.author)** on `\(.path):\(.line // "?")`: \(.body)"' 2>/dev/null | head -50)
          
          CONTEXT="Synthesize this AI feedback for a PR:

          ## Reviews ($REVIEW_COUNT)
          $REVIEW_TEXT

          ## Active Suggestions ($THREAD_COUNT)  
          $THREAD_TEXT

          Create a concise actionable summary:
          1. ðŸ”´ **Critical** - Must fix (security, bugs)
          2. ðŸŸ  **Important** - Should fix (performance, logic)
          3. ðŸŸ¡ **Suggested** - Nice to have (style, clarity)
          4. âœ… **Already Good** - Positive feedback
          5. ðŸ“Š **Verdict** - Ready to merge? What's blocking?"
          
          # Call Ollama for AI synthesis
          SYNTHESIS=""
          if [ -n "$OLLAMA_API_KEY" ] && [ -n "$OLLAMA_API_URL" ]; then
            SYNTHESIS=$(curl -sf --max-time 60 \
              -H "Authorization: Bearer $OLLAMA_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$(jq -n --arg prompt "$CONTEXT" '{
                model: "glm-4.6:cloud",
                messages: [
                  {role: "system", content: "Expert code reviewer. Be concise."},
                  {role: "user", content: $prompt}
                ],
                stream: false
              }')" \
              "$OLLAMA_API_URL/api/chat" 2>/dev/null | jq -r '.message.content // empty') || true
          fi
          
          # Build the ONE aggregate comment
          MARKER="CASCADE Review Synthesis"
          
          if [ -n "$SYNTHESIS" ]; then
            BODY="## ðŸ”¬ $MARKER

          **Analyzed:** $REVIEW_COUNT reviews, $THREAD_COUNT suggestions | **Resolved:** $RESOLVED outdated

          $SYNTHESIS

          ---
          <sub>ðŸ¤– Synthesized by CASCADE | Use \`@cascade address feedback\` to auto-fix</sub>"
          else
            BODY="## ðŸ”¬ $MARKER

          **Analyzed:** $REVIEW_COUNT reviews, $THREAD_COUNT suggestions | **Resolved:** $RESOLVED outdated

          ### Active Feedback
          $THREAD_TEXT

          ---
          <sub>ðŸ¤– Use \`@cascade synthesize\` for AI-powered summary</sub>"
          fi
          
          # Find and UPDATE existing synthesis, or create new
          EXISTING_ID=$(gh api repos/${{ github.repository }}/issues/$PR_NUM/comments --jq "
            .[] | select(.body | contains(\"$MARKER\")) | .node_id
          " 2>/dev/null | tail -1)
          
          if [ -n "$EXISTING_ID" ]; then
            echo "  Updating existing synthesis comment..."
            gh api graphql -f query='mutation($id: ID!, $body: String!) {
              updateIssueComment(input: {id: $id, body: $body}) { clientMutationId }
            }' -f id="$EXISTING_ID" -f body="$BODY" 2>/dev/null || gh pr comment $PR_NUM --body "$BODY"
          else
            echo "  Creating new synthesis comment..."
            gh pr comment $PR_NUM --body "$BODY"
          fi
          
          echo ""
          echo "âœ… Synthesis complete - ONE aggregate comment for CASCADE"

  # Automatic AI review on new/updated PRs
  auto-review:
    name: Auto Review
    if: github.event_name == 'pull_request' && !github.event.pull_request.draft
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: AI Review
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          MARKER="Cascade Auto-Review"
          
          # Check for existing review comment (dedup)
          EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | head -1)
          if [ -n "$EXISTING" ]; then
            echo "Review comment already exists, skipping"
            exit 0
          fi
          
          DIFF=$(git diff origin/${{ github.event.pull_request.base.ref }}...HEAD -- '*.py' '*.ts' '*.js' '*.tsx' '*.jsx' '*.go' '*.rs' | head -3000)
          
          if [ -z "$DIFF" ]; then
            echo "No code changes to review"
            exit 0
          fi
          
          gh pr comment $PR_NUM --body "ðŸ¤– **$MARKER**
          
          Analyzing PR changes..."

  # Unified @cascade trigger - routes to optimal AI agent
  cascade:
    name: Cascade
    if: |
      github.event_name == 'issue_comment' &&
      contains(github.event.comment.body, '@cascade') &&
      !contains(github.event.comment.body, '@cascade rebase') &&
      !contains(github.event.comment.body, '@cascade synthesize')
    runs-on: ubuntu-latest
    outputs:
      route: ${{ steps.route.outputs.agent }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Route to optimal agent
        id: route
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          echo "ðŸ”€ Cascade routing..."
          
          # Extract task from comment
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          # Determine optimal agent based on task keywords
          AGENT="claude"  # Default to Claude for most tasks
          
          # Quick questions/explanations -> Ollama (cheapest)
          if echo "$TASK" | grep -qiE "(explain|what is|how does|why|describe|summarize|question)"; then
            AGENT="ollama"
          fi
          
          # Multi-file refactors, large changes -> Jules
          if echo "$TASK" | grep -qiE "(refactor|rename across|update all|migrate|bulk|across files|multi-file)"; then
            AGENT="jules"
          fi
          
          # Long-running, complex debugging -> Cursor
          if echo "$TASK" | grep -qiE "(debug|investigate|long|complex|deep dive|root cause|trace)"; then
            AGENT="cursor"
          fi
          
          # Merge conflicts, rebase -> Claude (can handle git)
          if echo "$TASK" | grep -qiE "(rebase|merge|conflict|resolve|sync with main)"; then
            AGENT="claude"
          fi
          
          # Code review, fix issues -> Claude
          if echo "$TASK" | grep -qiE "(review|fix|address feedback|implement|add|update|change)"; then
            AGENT="claude"
          fi
          
          echo "agent=$AGENT" >> $GITHUB_OUTPUT
          echo "Selected agent: $AGENT"
          
          # Post acknowledgment (no dedup needed - user explicitly triggered)
          echo "agent=$AGENT" >> $GITHUB_OUTPUT
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "ðŸŒŠ **Cascade** â†’ **$AGENT**: $TASK"
          else
            gh issue comment $ISSUE_NUM --body "ðŸŒŠ **Cascade** â†’ **$AGENT**: $TASK"
          fi

  # Route: Claude (default for most tasks)
  cascade-claude:
    name: Claude
    needs: cascade
    if: needs.cascade.outputs.route == 'claude'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - uses: anthropics/claude-code-action@154d0de144ff82240e1c3deedff56280381fd122 # latest
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.CI_GITHUB_TOKEN }}
          allowed_bots: '*'
          trigger_phrase: '@cascade'

  # Route: Ollama (cheapest - for quick questions)
  cascade-ollama:
    name: Ollama
    needs: cascade
    if: needs.cascade.outputs.route == 'ollama'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Query Ollama
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          OLLAMA_API_URL: ${{ vars.OLLAMA_API_URL || 'https://api.ollama.com' }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          ISSUE_NUM="${{ github.event.issue.number }}"
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          
          # Simple acknowledgment (Ollama API integration would go here)
          RESPONSE="ðŸ¤– **Ollama Response**
          
          Processing: $TASK
          
          _(Cost-optimized quick response)_"
          
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "$RESPONSE"
          else
            gh issue comment $ISSUE_NUM --body "$RESPONSE"
          fi

  # Route: Jules (for multi-file refactors)
  cascade-jules:
    name: Jules
    needs: cascade
    if: needs.cascade.outputs.route == 'jules'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Delegate to Jules
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          GOOGLE_JULES_API_KEY: ${{ secrets.GOOGLE_JULES_API_KEY }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          ISSUE_NUM="${{ github.event.issue.number }}"
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          
          RESPONSE="ðŸ¤– **Jules Session**
          
          Task: $TASK
          
          Jules will create a session for multi-file refactoring.
          _(Optimized for large-scale changes)_"
          
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "$RESPONSE"
          else
            gh issue comment $ISSUE_NUM --body "$RESPONSE"
          fi

  # Route: Cursor (for long-running complex tasks)
  cascade-cursor:
    name: Cursor
    needs: cascade
    if: needs.cascade.outputs.route == 'cursor'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Delegate to Cursor
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          COMMENT: ${{ github.event.comment.body }}
        run: |
          TASK=$(echo "$COMMENT" | sed 's/@cascade//' | xargs)
          ISSUE_NUM="${{ github.event.issue.number }}"
          IS_PR="${{ github.event.issue.pull_request && 'true' || 'false' }}"
          
          RESPONSE="ðŸ¤– **Cursor Agent**
          
          Task: $TASK
          
          Cursor background agent spawned for deep investigation.
          _(Optimized for complex debugging)_"
          
          if [ "$IS_PR" = "true" ]; then
            gh pr comment $ISSUE_NUM --body "$RESPONSE"
          else
            gh issue comment $ISSUE_NUM --body "$RESPONSE"
          fi

  # Legacy support: direct @claude still works
  claude-direct:
    name: Claude (Direct)
    if: |
      github.event_name == 'issue_comment' &&
      contains(github.event.comment.body, '@claude') &&
      !contains(github.event.comment.body, '@cascade')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - uses: anthropics/claude-code-action@154d0de144ff82240e1c3deedff56280381fd122 # latest
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.CI_GITHUB_TOKEN }}
          allowed_bots: '*'

  # ============================================================
  # CI-FIX: Attempt to fix CI failures
  # ============================================================
  ci-fix:
    name: CI Fix
    if: |
      github.event_name == 'check_suite' &&
      github.event.check_suite.conclusion == 'failure' &&
      github.event.check_suite.pull_requests[0] != null
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}
          ref: ${{ github.event.check_suite.head_branch }}

      - name: Analyze and suggest fix
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=$(echo '${{ toJson(github.event.check_suite.pull_requests) }}' | jq -r '.[0].number')
          
          if [ "$PR_NUM" = "null" ] || [ -z "$PR_NUM" ]; then
            echo "No PR associated with this check suite"
            exit 0
          fi
          
          # Get failed check runs
          FAILED=$(gh api repos/${{ github.repository }}/check-suites/${{ github.event.check_suite.id }}/check-runs \
            --jq '.check_runs[] | select(.conclusion == "failure") | .name' | head -5)
          
          # Check for recent CI failure comment (within last 3 comments)
          MARKER="CI Failure Detected"
          RECENT=$(gh pr view $PR_NUM --json comments --jq ".comments[-3:] | .[] | select(.body | contains(\"$MARKER\")) | .id" | head -1)
          if [ -n "$RECENT" ]; then
            echo "Recent CI failure comment exists, skipping"
            exit 0
          fi
          
          gh pr comment $PR_NUM --body "âŒ **$MARKER**

          Failed checks:
          \`\`\`
          $FAILED
          \`\`\`

          Use \`@cascade fix the CI failures\` for AI-assisted debugging."

  # ============================================================
  # AUTO-MERGE: Merge when ready
  # ============================================================
  auto-merge:
    name: Auto Merge
    if: |
      github.event_name == 'pull_request_review' &&
      github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - name: Check and merge
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          
          # Check if auto-merge label exists
          HAS_AUTO=$(gh pr view $PR_NUM --json labels --jq '.labels[].name' | grep -c "auto-merge" || true)
          
          if [ "$HAS_AUTO" -eq 0 ]; then
            echo "No auto-merge label, skipping"
            exit 0
          fi
          
          # Check all status checks
          STATUS=$(gh pr checks $PR_NUM --json state --jq '.[] | select(.state != "SUCCESS" and .state != "SKIPPED") | .state' | head -1)
          
          if [ -n "$STATUS" ]; then
            echo "Checks not all passing, waiting..."
            exit 0
          fi
          
          # Merge
          gh pr merge $PR_NUM --squash --delete-branch --body "Auto-merged after approval"
          
          echo "âœ… PR #$PR_NUM merged"

  # ============================================================
  # SYNC-TRIAGE: Handle sync PRs from control center
  # ============================================================
  sync-triage:
    name: Sync Triage
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'opened' &&
      contains(github.event.pull_request.title, 'sync:')
    runs-on: ubuntu-latest
    steps:
      - name: Auto-approve sync PRs
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          
          # Mark ready for review if draft
          if [ "${{ github.event.pull_request.draft }}" = "true" ]; then
            echo "Converting draft to ready for review..."
            gh pr ready $PR_NUM || true
          fi
          
          # Add label for tracking
          gh pr edit $PR_NUM --add-label "sync,auto-merge"
          
          # Approve if from trusted source
          AUTHOR="${{ github.event.pull_request.user.login }}"
          
          if [[ "$AUTHOR" == *"[bot]"* ]] || [ "$AUTHOR" = "jbcom" ]; then
            gh pr review $PR_NUM --approve --body "âœ… Approved: Sync from control center"
          fi

  # ============================================================
  # AUTO-REBASE: Rebase PRs with merge conflicts
  # ============================================================
  auto-rebase:
    name: Auto Rebase
    if: |
      (github.event_name == 'pull_request' &&
       (github.event.action == 'synchronize' || github.event.action == 'opened')) ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, '@cascade rebase'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Check and rebase if needed
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # Get PR info
          if [ "${{ github.event_name }}" = "issue_comment" ]; then
            PR_NUM="${{ github.event.issue.number }}"
            # Verify it's a PR, not an issue
            if [ -z "${{ github.event.issue.pull_request }}" ]; then
              echo "Not a PR, skipping"
              exit 0
            fi
          else
            PR_NUM="${{ github.event.pull_request.number }}"
          fi
          
          # Get PR details
          PR_DATA=$(gh pr view $PR_NUM --json headRefName,baseRefName,mergeable,mergeStateStatus)
          HEAD_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
          BASE_BRANCH=$(echo "$PR_DATA" | jq -r '.baseRefName')
          MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')
          MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus')
          
          echo "PR #$PR_NUM: $HEAD_BRANCH -> $BASE_BRANCH"
          echo "Mergeable: $MERGEABLE, State: $MERGE_STATE"
          
          # Check if rebase is needed
          if [ "$MERGEABLE" = "CONFLICTING" ] || [ "$MERGE_STATE" = "BEHIND" ] || [ "$MERGE_STATE" = "DIRTY" ]; then
            echo "ðŸ”„ Rebase needed..."
            
            # Configure git
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            # Fetch all branches
            git fetch origin $BASE_BRANCH
            git fetch origin $HEAD_BRANCH
            
            # Checkout the PR branch
            git checkout $HEAD_BRANCH
            
            # Attempt rebase
            if git rebase origin/$BASE_BRANCH; then
              echo "âœ… Rebase successful"
              
              # Force push with lease
              if git push --force-with-lease origin $HEAD_BRANCH; then
                echo "âœ… Force push successful"
                # No comment on success - reduces noise
              else
                echo "âŒ Force push failed"
                # Only comment on failure, check for existing
                MARKER="Auto-Rebase Failed"
                EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | tail -1)
                [ -z "$EXISTING" ] && gh pr comment $PR_NUM --body "âš ï¸ **$MARKER** - Rebase succeeded but force push failed. Please rebase manually."
              fi
            else
              echo "âŒ Rebase failed - conflicts require manual resolution"
              git rebase --abort 2>/dev/null || true
              
              # Only comment if no recent failure comment
              MARKER="Auto-Rebase Failed"
              EXISTING=$(gh pr view $PR_NUM --json comments --jq ".comments[] | select(.body | contains(\"$MARKER\")) | .id" | tail -1)
              [ -z "$EXISTING" ] && gh pr comment $PR_NUM --body "âš ï¸ **$MARKER** - Conflicts require manual resolution. Use \`@cascade resolve conflicts\` for help."
            fi
          else
            echo "âœ… No rebase needed - PR is up to date"
          fi

  # ============================================================
  # MERGE-READY: Check if PR is ready to merge and do it
  # ============================================================
  merge-ready:
    name: Merge Ready
    if: |
      (github.event_name == 'check_suite' &&
       github.event.check_suite.conclusion == 'success') ||
      (github.event_name == 'pull_request' &&
       github.event.action == 'synchronize') ||
      (github.event_name == 'pull_request_review' &&
       github.event.review.state == 'approved')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Check and merge eligible PRs
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # Get PR number(s) based on event type
          if [ "${{ github.event_name }}" = "check_suite" ]; then
            PRS='${{ toJson(github.event.check_suite.pull_requests) }}'
            PR_NUMS=$(echo "$PRS" | jq -r '.[].number' 2>/dev/null || echo "")
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_NUMS="${{ github.event.pull_request.number }}"
          elif [ "${{ github.event_name }}" = "pull_request_review" ]; then
            PR_NUMS="${{ github.event.pull_request.number }}"
          else
            PR_NUMS=""
          fi
          
          for PR_NUM in $PR_NUMS; do
            [ -z "$PR_NUM" ] && continue
            [ "$PR_NUM" = "null" ] && continue
            
            echo "Checking PR #$PR_NUM..."
            
            # Get PR details
            PR_DATA=$(gh pr view $PR_NUM --json labels,reviewDecision,mergeable,mergeStateStatus,isDraft)
            
            IS_DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft')
            MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')
            MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus')
            REVIEW=$(echo "$PR_DATA" | jq -r '.reviewDecision')
            HAS_AUTO=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "auto-merge" || echo "0")
            HAS_SYNC=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "sync" || echo "0")
            
            echo "  Draft: $IS_DRAFT, Mergeable: $MERGEABLE, State: $MERGE_STATE"
            echo "  Review: $REVIEW, Auto-merge: $HAS_AUTO, Sync: $HAS_SYNC"
            
            # Skip drafts
            if [ "$IS_DRAFT" = "true" ]; then
              echo "  Skipping - draft PR"
              continue
            fi
            
            # Check if auto-merge eligible
            if [ "$HAS_AUTO" -eq 0 ] && [ "$HAS_SYNC" -eq 0 ]; then
              echo "  Skipping - no auto-merge or sync label"
              continue
            fi
            
            # Check if behind - trigger rebase (but don't spam)
            if [ "$MERGE_STATE" = "BEHIND" ] || [ "$MERGEABLE" = "CONFLICTING" ]; then
              # Check if we already requested rebase recently
              RECENT_REBASE=$(gh pr view $PR_NUM --json comments --jq '.comments[-5:] | .[] | select(.body | contains("@cascade rebase")) | .id' | head -1)
              if [ -z "$RECENT_REBASE" ]; then
                echo "  PR needs rebase, triggering..."
                gh pr comment $PR_NUM --body "@cascade rebase"
              else
                echo "  PR needs rebase but already requested recently"
              fi
              continue
            fi
            
            # Check if ready to merge
            if [ "$MERGEABLE" = "MERGEABLE" ] && [ "$MERGE_STATE" = "CLEAN" ]; then
              # Sync PRs can merge without review approval
              if [ "$HAS_SYNC" -gt 0 ]; then
                echo "  âœ… Merging sync PR..."
                gh pr merge $PR_NUM --squash --delete-branch --body "Auto-merged: sync from control center" || echo "  Merge failed"
              elif [ "$REVIEW" = "APPROVED" ]; then
                echo "  âœ… Merging approved PR..."
                gh pr merge $PR_NUM --squash --delete-branch --body "Auto-merged after approval" || echo "  Merge failed"
              else
                echo "  Skipping - awaiting review approval"
              fi
            else
              echo "  Skipping - not in mergeable state"
            fi
          done

  # ============================================================
  # DRAFT-READY: Convert drafts to ready when CI passes
  # ============================================================
  draft-ready:
    name: Draft Ready
    if: |
      github.event_name == 'check_suite' &&
      github.event.check_suite.conclusion == 'success' &&
      github.event.check_suite.pull_requests[0] != null
    runs-on: ubuntu-latest
    steps:
      - name: Mark ready if draft and CI passed
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          PR_NUM=$(echo '${{ toJson(github.event.check_suite.pull_requests) }}' | jq -r '.[0].number')
          
          if [ "$PR_NUM" = "null" ] || [ -z "$PR_NUM" ]; then
            exit 0
          fi
          
          # Check if PR is draft
          IS_DRAFT=$(gh pr view $PR_NUM --json isDraft --jq '.isDraft')
          
          if [ "$IS_DRAFT" = "true" ]; then
            echo "CI passed - converting draft PR #$PR_NUM to ready for review"
            gh pr ready $PR_NUM
            # No comment - the ready_for_review event will trigger auto-review
          fi

  # ============================================================
  # SELF-ASSESS: Automatically evaluate ALL PRs for auto-merge
  # This is what makes the ecosystem-connector truly autonomous
  # Runs on EVERY relevant event - evaluation determines eligibility
  # ============================================================
  self-assess:
    name: Self Assess
    if: |
      (github.event_name == 'pull_request') ||
      (github.event_name == 'pull_request_review') ||
      (github.event_name == 'check_suite' &&
       github.event.check_suite.conclusion == 'success' &&
       github.event.check_suite.pull_requests[0] != null) ||
      (github.event_name == 'check_run' &&
       github.event.check_run.conclusion == 'success' &&
       github.event.check_run.pull_requests[0] != null) ||
      (github.event_name == 'status' &&
       github.event.state == 'success')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - name: Assess and auto-approve if eligible
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          # Get PR number from various event types
          case "${{ github.event_name }}" in
            pull_request)
              PR_NUM="${{ github.event.pull_request.number }}"
              ;;
            pull_request_review)
              PR_NUM="${{ github.event.pull_request.number }}"
              ;;
            check_suite)
              PR_NUM=$(echo '${{ toJson(github.event.check_suite.pull_requests) }}' | jq -r '.[0].number')
              ;;
            check_run)
              PR_NUM=$(echo '${{ toJson(github.event.check_run.pull_requests) }}' | jq -r '.[0].number')
              ;;
            status)
              # Status events don't have direct PR association - need to find via commit
              COMMIT="${{ github.event.commit.sha }}"
              PR_NUM=$(gh pr list --state open --json number,headRefOid --jq ".[] | select(.headRefOid == \"$COMMIT\") | .number" | head -1)
              ;;
            *)
              PR_NUM=""
              ;;
          esac
          
          if [ "$PR_NUM" = "null" ] || [ -z "$PR_NUM" ]; then
            echo "No PR to assess"
            exit 0
          fi
          
          echo "ðŸ” Self-assessing PR #$PR_NUM..."
          
          # Get PR details
          PR_DATA=$(gh pr view $PR_NUM --json author,labels,isDraft,mergeable,mergeStateStatus,reviewDecision,title,headRefName)
          
          AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')
          IS_DRAFT=$(echo "$PR_DATA" | jq -r '.isDraft')
          MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable')
          MERGE_STATE=$(echo "$PR_DATA" | jq -r '.mergeStateStatus')
          REVIEW=$(echo "$PR_DATA" | jq -r '.reviewDecision')
          TITLE=$(echo "$PR_DATA" | jq -r '.title')
          BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
          HAS_AUTO=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "auto-merge" || echo "0")
          HAS_SYNC=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "sync" || echo "0")
          
          echo "  Author: $AUTHOR"
          echo "  Title: $TITLE"
          echo "  Branch: $BRANCH"
          echo "  Draft: $IS_DRAFT, Mergeable: $MERGEABLE, State: $MERGE_STATE"
          echo "  Review: $REVIEW, Has auto-merge: $HAS_AUTO, Has sync: $HAS_SYNC"
          
          # Skip if draft
          if [ "$IS_DRAFT" = "true" ]; then
            echo "  Skipping - draft PR"
            exit 0
          fi
          
          # Skip if already has labels
          if [ "$HAS_AUTO" -gt 0 ] || [ "$HAS_SYNC" -gt 0 ]; then
            echo "  Already labeled for auto-merge"
            exit 0
          fi
          
          # Check all CI status
          FAILED_CHECKS=$(gh pr checks $PR_NUM --json name,conclusion --jq '[.[] | select(.conclusion == "FAILURE" or .conclusion == "TIMED_OUT")] | length')
          PENDING_CHECKS=$(gh pr checks $PR_NUM --json name,state --jq '[.[] | select(.state == "PENDING" or .state == "QUEUED")] | length')
          
          echo "  Failed checks: $FAILED_CHECKS, Pending: $PENDING_CHECKS"
          
          # Don't proceed if checks are failing or pending
          if [ "$FAILED_CHECKS" -gt 0 ]; then
            echo "  Skipping - has failing checks"
            exit 0
          fi
          
          if [ "$PENDING_CHECKS" -gt 0 ]; then
            echo "  Skipping - checks still pending"
            exit 0
          fi
          
          # ALL PRs are eligible for auto-merge if:
          # 1. All CI checks pass (already verified above)
          # 2. PR is mergeable
          # 3. Not a draft
          # Safety comes from CI checks, not arbitrary criteria
          
          if [ "$MERGEABLE" != "MERGEABLE" ]; then
            echo "  Skipping - not in mergeable state ($MERGEABLE)"
            exit 0
          fi
          
          echo "  âœ… All CI passed, PR is mergeable - enabling auto-merge"
          
          # Create auto-merge label if it doesn't exist
          gh label create "auto-merge" --description "Eligible for automatic merging" --color "0E8A16" 2>/dev/null || true
          
          # Add label
          gh pr edit $PR_NUM --add-label "auto-merge"
          
          # Auto-approve (if not already approved)
          if [ "$REVIEW" != "APPROVED" ]; then
            APPROVE_BODY=$(cat << 'EOFBODY'
          âœ… **Auto-approved by Ecosystem Connector**

          All CI checks passed. PR is mergeable.

          | Check | Status |
          |-------|--------|
          | CI Passing | âœ… |
          | Mergeable | âœ… |
          | Draft | âŒ |

          Proceeding with auto-merge.
          EOFBODY
          )
            gh pr review $PR_NUM --approve --body "$APPROVE_BODY" || echo "  Could not auto-approve (may need different permissions)"
          fi
          
          echo "  âœ… Added auto-merge label and approved"
          
          # ============================================================
          # RESOLVE OUTDATED FEEDBACK
          # Clean up resolved/outdated AI feedback as part of self-assess
          # ============================================================
          echo ""
          echo "ðŸ§¹ Cleaning up outdated feedback..."
          
          # GraphQL to get all review threads
          QUERY='query($owner: String!, $repo: String!, $pr: Int!) {
            repository(owner: $owner, name: $repo) {
              pullRequest(number: $pr) {
                reviewThreads(first: 100) {
                  nodes {
                    id
                    isResolved
                    isOutdated
                    path
                    comments(first: 1) {
                      nodes {
                        author { login }
                        body
                      }
                    }
                  }
                }
              }
            }
          }'
          
          OWNER="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          
          THREADS=$(gh api graphql -f query="$QUERY" -f owner="$OWNER" -f repo="$REPO" -F pr="$PR_NUM" 2>/dev/null || echo "{}")
          
          # Known AI agents whose outdated feedback can be auto-resolved
          AI_AGENTS="copilot|github-actions|coderabbitai|gemini|amazon-q|dependabot|cursor|bugbot|claude|sonarcloud|codacy|snyk"
          
          # Find outdated, unresolved threads from AI agents
          OUTDATED_IDS=$(echo "$THREADS" | jq -r --arg agents "$AI_AGENTS" '
            .data.repository.pullRequest.reviewThreads.nodes[]? |
            select(.isOutdated == true and .isResolved == false) |
            select(.comments.nodes[0].author.login | test($agents; "i")) |
            .id
          ' 2>/dev/null || echo "")
          
          RESOLVED_COUNT=0
          
          for THREAD_ID in $OUTDATED_IDS; do
            [ -z "$THREAD_ID" ] && continue
            
            echo "  Resolving outdated thread: $THREAD_ID"
            
            gh api graphql -f query='mutation($id: ID!) {
              resolveReviewThread(input: {threadId: $id}) {
                thread { isResolved }
              }
            }' -f id="$THREAD_ID" 2>/dev/null && RESOLVED_COUNT=$((RESOLVED_COUNT + 1))
          done
          
          echo "  âœ… Resolved $RESOLVED_COUNT outdated AI review threads"
          
          # Minimize stale bot comments (CodeQL, security scanners, etc)
          STALE_COMMENTS=$(gh api repos/${{ github.repository }}/issues/$PR_NUM/comments --jq '
            [.[] | select(.user.type == "Bot" or (.user.login | test("codeql|snyk|sonar|codacy|dependabot"; "i"))) | .node_id] | .[]
          ' 2>/dev/null || echo "")
          
          # Only minimize if there are many comments (>10) to reduce noise
          COMMENT_COUNT=$(echo "$STALE_COMMENTS" | grep -c . || echo "0")
          if [ "$COMMENT_COUNT" -gt 10 ]; then
            echo "  Found $COMMENT_COUNT bot comments, minimizing older ones..."
            # Minimize all but the last 5
            echo "$STALE_COMMENTS" | head -n -5 | while read -r COMMENT_ID; do
              [ -z "$COMMENT_ID" ] && continue
              gh api graphql -f query='mutation($id: ID!) {
                minimizeComment(input: {subjectId: $id, classifier: OUTDATED}) {
                  minimizedComment { isMinimized }
                }
              }' -f id="$COMMENT_ID" 2>/dev/null || true
            done
            echo "  âœ… Minimized stale bot comments"
          fi
