# Master CI/CD orchestration workflow
#
# Uses reusable workflows with stacked matrices:
# - Package x Python version for testing
# - Package x Target repo for sync/release/docs
#
# On PR:   Test + Lint
# On main: Test + Lint + Version (per-package via PSR) + Sync + Release + Docs + Enforce Standards
#
# VERSIONING: python-semantic-release manages per-package versions via Git tags
# Each package has independent versioning based on conventional commits
# Version format: 202511.MINOR.PATCH (CalVer-compatible SemVer starting at major 202511)

name: CI

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:
    inputs:
      enforce_standards:
        description: 'Run standards enforcement'
        type: boolean
        default: false
      force_release:
        description: 'Force release even without changes'
        type: boolean
        default: false

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

# Permissions for PyPI trusted publishing and Git operations
permissions:
  contents: write       # Push tags and version commits
  pull-requests: write  # Comment on PRs
  id-token: write       # PyPI trusted publishing
  pages: write          # Deploy documentation
  attestations: write   # Build attestations

jobs:
  # ============================================
  # MATRIX DEFINITION
  # ============================================
  matrix:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.set.outputs.packages }}
      test-matrix: ${{ steps.set.outputs.test-matrix }}
      deploy-matrix: ${{ steps.set.outputs.deploy-matrix }}
    steps:
      - id: set
        run: |
          # Package definitions with dependency order
          PACKAGES='[{"name":"extended-data-types","pypi":"extended-data-types","repo":"jbcom/extended-data-types","deps":[]},{"name":"lifecyclelogging","pypi":"lifecyclelogging","repo":"jbcom/lifecyclelogging","deps":["extended-data-types"]},{"name":"directed-inputs-class","pypi":"directed-inputs-class","repo":"jbcom/directed-inputs-class","deps":["extended-data-types"]},{"name":"vendor-connectors","pypi":"vendor-connectors","repo":"jbcom/vendor-connectors","deps":["extended-data-types","lifecyclelogging"]}]'
          
          PYTHON_VERSIONS='["3.9","3.13"]'
          
          # Test matrix: package x python
          TEST_MATRIX=$(echo "$PACKAGES" | jq -c --argjson py "$PYTHON_VERSIONS" '{package: [.[].name], python: $py}')
          
          # Deploy matrix: packages with metadata
          DEPLOY_MATRIX=$(echo "$PACKAGES" | jq -c '{include: .}')
          
          echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
          echo "test-matrix=$TEST_MATRIX" >> $GITHUB_OUTPUT
          echo "deploy-matrix=$DEPLOY_MATRIX" >> $GITHUB_OUTPUT

  # ============================================
  # TEST (package x python matrix)
  # ============================================
  test:
    needs: matrix
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.test-matrix) }}
    uses: ./.github/workflows/reusable-test.yml
    with:
      package: ${{ matrix.package }}
      python-version: ${{ matrix.python }}

  # ============================================
  # LINT (once)
  # ============================================
  lint:
    uses: ./.github/workflows/reusable-lint.yml

  # ============================================
  # VERSION & RELEASE - Per-package semantic versioning (main only)
  # Uses python-semantic-release with monorepo parser
  # Combines version, sync, and release into one job per package
  # ============================================
  release:
    needs: [matrix, test, lint]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 1  # Release packages sequentially (dependency order)
      matrix: ${{ fromJson(needs.matrix.outputs.deploy-matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for PSR to analyze commits
          token: ${{ secrets.CI_GITHUB_TOKEN }}

      - uses: astral-sh/setup-uv@v7

      - name: Install dependencies
        run: |
          uv pip install --system python-semantic-release

      - name: Get current version
        id: current
        run: |
          VERSION=$(grep '^version = ' packages/${{ matrix.name }}/pyproject.toml | head -1 | sed 's/version = "\([^"]*\)"/\1/')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"

      - name: Check for version bump
        id: check
        working-directory: packages/${{ matrix.name }}
        run: |
          # Check if PSR would create a new version
          set +e
          NEW_VERSION=$(semantic-release --noop version --print 2>/dev/null)
          EXIT_CODE=$?
          set -e
          
          CURRENT="${{ steps.current.outputs.version }}"
          
          if [ $EXIT_CODE -eq 0 ] && [ -n "$NEW_VERSION" ] && [ "$NEW_VERSION" != "$CURRENT" ]; then
            echo "Will release: $CURRENT -> $NEW_VERSION"
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          else
            echo "No release needed for ${{ matrix.name }}"
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "new_version=$CURRENT" >> $GITHUB_OUTPUT
          fi

      - name: Create release
        if: steps.check.outputs.should_release == 'true'
        working-directory: packages/${{ matrix.name }}
        run: |
          echo "Releasing ${{ matrix.name }} v${{ steps.check.outputs.new_version }}"
          
          # Configure git
          git config user.name "jbcom-bot"
          git config user.email "jbcom-bot@users.noreply.github.com"
          
          # Run semantic-release (creates tag, bumps version, commits)
          semantic-release version
          
          # Push changes and tags
          git push origin main --follow-tags

      - name: Build package
        run: |
          VERSION="${{ steps.check.outputs.new_version }}"
          echo "Building ${{ matrix.name }} v$VERSION"
          uv build --package ${{ matrix.name }}
          ls -la dist/

      - name: Publish to PyPI
        env:
          UV_PUBLISH_TOKEN: ${{ secrets.PYPI_TOKEN }}
        run: |
          VERSION="${{ steps.check.outputs.new_version }}"
          
          if uv publish 2>&1 | tee publish.log; then
            echo "‚úÖ Published ${{ matrix.pypi }} v$VERSION to PyPI"
          else
            if grep -qE "(already exists|File already exists)" publish.log; then
              echo "‚ö†Ô∏è Version $VERSION already exists on PyPI (skipping)"
            else
              echo "‚ùå Failed to publish"
              cat publish.log
              exit 1
            fi
          fi

      - name: Sync to public repo
        env:
          GH_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.check.outputs.new_version }}"
          REPO="${{ matrix.repo }}"
          
          echo "Syncing ${{ matrix.name }} v$VERSION to $REPO"
          
          # Clone target repo
          git clone "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git" target
          
          # Clear and copy
          cd target
          find . -mindepth 1 -maxdepth 1 ! -name '.git' -exec rm -rf {} +
          cp -r ../packages/${{ matrix.name }}/* .
          
          # Commit and push
          git config user.name "jbcom-bot"
          git config user.email "jbcom-bot@users.noreply.github.com"
          git add -A
          
          if git diff --staged --quiet; then
            echo "No changes to sync"
          else
            git commit -m "üöÄ Release v$VERSION from control-center"
            git push
            echo "‚úÖ Synced to $REPO"
          fi

  # ============================================
  # DEPLOY DOCS (main only, after release)
  # ============================================
  docs:
    needs: [matrix, release]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.deploy-matrix) }}
    uses: ./.github/workflows/reusable-docs.yml
    with:
      package: ${{ matrix.name }}
      target-repo: ${{ matrix.repo }}
      version: "latest"  # Docs workflow will read actual version from package
    secrets:
      token: ${{ secrets.CI_GITHUB_TOKEN }}

  # ============================================
  # ENFORCE STANDARDS (main or manual, non-blocking)
  # ============================================
  enforce:
    needs: [matrix, test, lint]
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && inputs.enforce_standards)
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.deploy-matrix) }}
    uses: ./.github/workflows/reusable-enforce-standards.yml
    with:
      repo: ${{ matrix.repo }}
    secrets:
      token: ${{ secrets.CI_GITHUB_TOKEN }}
