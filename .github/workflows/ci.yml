# Master CI/CD orchestration workflow
#
# Uses reusable workflows with stacked matrices:
# - Package x Python version for testing
# - Package x Target repo for sync/release/docs
#
# On PR:   Test + Lint
# On main: Test + Lint + Version + Sync + Release + Docs + Enforce Standards
#
# VERSIONING: pycalver generates ONE version at start, ALL packages use it

name: CI

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:
    inputs:
      enforce_standards:
        description: 'Run standards enforcement'
        type: boolean
        default: false

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================
  # MATRIX DEFINITION
  # ============================================
  matrix:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.set.outputs.packages }}
      test-matrix: ${{ steps.set.outputs.test-matrix }}
      deploy-matrix: ${{ steps.set.outputs.deploy-matrix }}
    steps:
      - id: set
        run: |
          # Package definitions - single line for GITHUB_OUTPUT compatibility
          PACKAGES='[{"name":"extended-data-types","pypi":"extended-data-types","repo":"jbcom/extended-data-types","deps":[]},{"name":"lifecyclelogging","pypi":"lifecyclelogging","repo":"jbcom/lifecyclelogging","deps":["extended-data-types"]},{"name":"directed-inputs-class","pypi":"directed-inputs-class","repo":"jbcom/directed-inputs-class","deps":["extended-data-types"]},{"name":"vendor-connectors","pypi":"cloud-connectors","repo":"jbcom/vendor-connectors","deps":["extended-data-types","lifecyclelogging"]}]'
          
          PYTHON_VERSIONS='["3.9","3.13"]'
          
          # Test matrix: package x python
          TEST_MATRIX=$(echo "$PACKAGES" | jq -c --argjson py "$PYTHON_VERSIONS" '{package: [.[].name], python: $py}')
          
          # Deploy matrix: packages with metadata
          DEPLOY_MATRIX=$(echo "$PACKAGES" | jq -c '{include: .}')
          
          echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
          echo "test-matrix=$TEST_MATRIX" >> $GITHUB_OUTPUT
          echo "deploy-matrix=$DEPLOY_MATRIX" >> $GITHUB_OUTPUT

  # ============================================
  # TEST (package x python matrix)
  # ============================================
  test:
    needs: matrix
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.test-matrix) }}
    uses: ./.github/workflows/reusable-test.yml
    with:
      package: ${{ matrix.package }}
      python-version: ${{ matrix.python }}

  # ============================================
  # LINT (once)
  # ============================================
  lint:
    uses: ./.github/workflows/reusable-lint.yml

  # ============================================
  # VERSION - Generate ONE version for ALL packages (main only)
  # ============================================
  version:
    needs: [test, lint]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.bump.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - uses: astral-sh/setup-uv@v4

      - name: Sync workspace (installs pycalver as dev dependency)
        run: uv sync --dev

      - name: Bump version with pycalver
        id: bump
        run: |
          # Show current version
          echo "Current version:"
          grep 'current_version' pyproject.toml | head -1
          
          # Bump to new version (config has commit=false, tag=false, push=false)
          uv run pycalver bump --release final
          
          # Extract new version
          NEW_VERSION=$(grep 'current_version' pyproject.toml | head -1 | sed 's/.*= *"\([^"]*\)".*/\1/')
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Show what was updated
          echo "=== Updated files ==="
          git diff --name-only
          
          # Verify all packages have the same version
          echo "=== Package versions ==="
          grep -r "__version__" packages/*/src/*/__init__.py || true

      - name: Upload versioned source
        uses: actions/upload-artifact@v4
        with:
          name: versioned-source
          path: |
            packages/
            pyproject.toml
          retention-days: 1

  # ============================================
  # SYNC TO PUBLIC REPOS (main only, after version)
  # ============================================
  sync:
    needs: [matrix, version]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    strategy:
      fail-fast: false
      max-parallel: 1  # Sync in order
      matrix: ${{ fromJson(needs.matrix.outputs.deploy-matrix) }}
    uses: ./.github/workflows/reusable-sync.yml
    with:
      package: ${{ matrix.name }}
      target-repo: ${{ matrix.repo }}
      version: ${{ needs.version.outputs.version }}
    secrets:
      token: ${{ secrets.CI_GITHUB_TOKEN }}

  # ============================================
  # RELEASE TO PYPI (main only, after sync)
  # ============================================
  release:
    needs: [matrix, version, sync]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    strategy:
      fail-fast: false
      max-parallel: 1  # Release in dependency order
      matrix: ${{ fromJson(needs.matrix.outputs.deploy-matrix) }}
    uses: ./.github/workflows/reusable-release.yml
    with:
      package: ${{ matrix.name }}
      pypi-name: ${{ matrix.pypi }}
      version: ${{ needs.version.outputs.version }}
    secrets:
      pypi-token: ${{ secrets.PYPI_TOKEN }}

  # ============================================
  # DEPLOY DOCS (main only, after release)
  # ============================================
  docs:
    needs: [matrix, version, release]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.deploy-matrix) }}
    uses: ./.github/workflows/reusable-docs.yml
    with:
      package: ${{ matrix.name }}
      target-repo: ${{ matrix.repo }}
      version: ${{ needs.version.outputs.version }}
    secrets:
      token: ${{ secrets.CI_GITHUB_TOKEN }}

  # ============================================
  # ENFORCE STANDARDS (main or manual, non-blocking)
  # ============================================
  enforce:
    needs: [matrix, test, lint]  # Run after tests pass, parallel to version/sync/release
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && inputs.enforce_standards)
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.deploy-matrix) }}
    uses: ./.github/workflows/reusable-enforce-standards.yml
    with:
      repo: ${{ matrix.repo }}
    secrets:
      token: ${{ secrets.CI_GITHUB_TOKEN }}
