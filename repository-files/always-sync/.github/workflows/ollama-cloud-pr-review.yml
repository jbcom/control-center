name: Ollama PR Orchestrator

# Autonomous PR lifecycle management:
# - Automatic code review on PR open
# - Monitors ALL AI agent feedback (Gemini, Copilot, Q, CodeRabbit, etc.)
# - Analyzes, triages, and resolves AI feedback automatically
# - Applies fixes and commits them
# - Resolves comment threads
# - Removes draft status when ready
# - Auto-merges when all feedback satisfied and CI green

on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
  pull_request_review:
    types: [submitted]
  pull_request_review_comment:
    types: [created]
  issue_comment:
    types: [created]
  check_suite:
    types: [completed]

permissions:
  contents: read

env:
  OLLAMA_HOST: ${{ vars.OLLAMA_HOST || 'https://ollama.com' }}
  OLLAMA_MODEL: ${{ vars.OLLAMA_MODEL || 'glm-4.6:cloud' }}
  # Known AI agent bot names - includes github-actions[bot] for self-feedback loop
  AI_AGENTS: "gemini-code-assist[bot],copilot[bot],amazon-q-developer[bot],coderabbitai[bot],cursor[bot],github-advanced-security[bot],dependabot[bot]"

jobs:
  # ============================================
  # Initial Review - On PR open/sync
  # ============================================
  initial-review:
    name: Initial Code Review
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    outputs:
      pr_number: ${{ github.event.pull_request.number }}
      recommendation: ${{ steps.review.outputs.recommendation }}
      score: ${{ steps.submit_review.outputs.score }}
      issues_count: ${{ steps.submit_review.outputs.issues_count }}
    
    steps:
      - name: Check required secrets
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
        run: |
          if [[ -z "$OLLAMA_API_KEY" ]]; then
            echo "::error::OLLAMA_API_KEY secret is not configured"
            exit 1
          fi

      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
          # Use CI_GITHUB_TOKEN to allow commits to trigger workflows
          token: ${{ secrets.CI_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Get PR diff
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr diff ${{ github.event.pull_request.number }} --color=never > /tmp/pr_diff.txt

      - name: Generate structured review
        id: review
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
        run: |
          # Schema for structured output
          cat > /tmp/schema.json << 'EOF'
          {
            "type": "object",
            "properties": {
              "summary": { "type": "string" },
              "issues": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "file": { "type": "string" },
                    "line": { "type": "integer" },
                    "severity": { "type": "string", "enum": ["low", "medium", "high", "critical"] },
                    "description": { "type": "string" },
                    "fix": { "type": "string" }
                  },
                  "required": ["file", "severity", "description"]
                }
              },
              "fixes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "file": { "type": "string" },
                    "old_content": { "type": "string" },
                    "new_content": { "type": "string" },
                    "description": { "type": "string" }
                  },
                  "required": ["file", "old_content", "new_content", "description"]
                }
              },
              "score": { "type": "integer", "minimum": 1, "maximum": 10 },
              "recommendation": { "type": "string", "enum": ["approve", "request_changes", "comment"] },
              "auto_apply": { "type": "boolean" }
            },
            "required": ["summary", "issues", "fixes", "score", "recommendation", "auto_apply"]
          }
          EOF
          
          cat > /tmp/prompt.txt << 'EOF'
          You are an expert code reviewer. Analyze this diff and provide:
          1. A concise summary
          2. List of issues by severity (critical, high, medium, low)
          3. Concrete fixes with exact old_content and new_content for search/replace
          4. A score from 1-10
          5. recommendation: approve (score >= 8, no critical/high), request_changes (critical/high issues), comment (otherwise)
          6. auto_apply: true only if fixes are safe refactoring with no behavior change
          
          Be thorough but practical. Focus on real issues, not style nitpicks.
          
          DIFF:
          EOF
          
          head -c 100000 /tmp/pr_diff.txt >> /tmp/prompt.txt
          
          jq -n \
            --arg model "$OLLAMA_MODEL" \
            --rawfile prompt /tmp/prompt.txt \
            --slurpfile schema /tmp/schema.json \
            '{
              model: $model,
              messages: [
                { role: "system", content: "Expert code reviewer. Respond with valid JSON only." },
                { role: "user", content: $prompt }
              ],
              format: $schema[0],
              options: { temperature: 0.1, num_ctx: 131072, num_predict: 8192 },
              stream: false
            }' > /tmp/payload.json
          
          if curl -sf --max-time 300 \
            -H "Authorization: Bearer $OLLAMA_API_KEY" \
            -H "Content-Type: application/json" \
            -d @/tmp/payload.json \
            "$OLLAMA_HOST/api/chat" > /tmp/response.json; then
            jq -r '.message.content // empty' /tmp/response.json > /tmp/review.json
          else
            echo '{"summary":"API error","issues":[],"fixes":[],"score":5,"recommendation":"comment","auto_apply":false}' > /tmp/review.json
          fi
          
          # Validate
          if ! jq empty /tmp/review.json 2>/dev/null; then
            echo '{"summary":"Parse error","issues":[],"fixes":[],"score":5,"recommendation":"comment","auto_apply":false}' > /tmp/review.json
          fi
          
          echo "recommendation=$(jq -r '.recommendation' /tmp/review.json)" >> $GITHUB_OUTPUT
          echo "auto_apply=$(jq -r '.auto_apply' /tmp/review.json)" >> $GITHUB_OUTPUT

      - name: Apply safe fixes
        if: steps.review.outputs.auto_apply == 'true'
        run: |
          jq -c '.fixes[]' /tmp/review.json | while read -r fix; do
            FILE=$(echo "$fix" | jq -r '.file')
            OLD=$(echo "$fix" | jq -r '.old_content')
            NEW=$(echo "$fix" | jq -r '.new_content')
            
            # Security check
            if [[ "$FILE" =~ \.\./|^/ ]]; then
              echo "Skipping unsafe path: $FILE"
              continue
            fi
            
            # Validate OLD is not empty (prevents file corruption)
            if [[ -z "$OLD" ]]; then
              echo "‚ö†Ô∏è Skipping fix with empty old_content"
              continue
            fi
            
            if [[ -f "$FILE" ]] && grep -qF "$OLD" "$FILE"; then
              # Use perl with environment variables to handle slashes in content
              OLD="$OLD" NEW="$NEW" perl -i -p0e 's/\Q$ENV{OLD}\E/$ENV{NEW}/s' "$FILE" && echo "‚úÖ Fixed: $FILE"
            fi
          done

      - name: Commit fixes
        if: steps.review.outputs.auto_apply == 'true'
        uses: stefanzweifel/git-auto-commit-action@04702edda442b2e678b25b537cec683a1493fcb9 # v7.1.0
        with:
          commit_message: "fix: auto-apply safe improvements (Ollama)"
          branch: ${{ github.head_ref }}

      - name: Submit review
        id: submit_review
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SUMMARY=$(jq -r '.summary' /tmp/review.json)
          SCORE=$(jq -r '.score' /tmp/review.json)
          REC=$(jq -r '.recommendation' /tmp/review.json)
          ISSUES=$(jq '.issues | length' /tmp/review.json)

          echo "score=$SCORE" >> $GITHUB_OUTPUT
          echo "issues_count=$ISSUES" >> $GITHUB_OUTPUT
          
          BODY="## ü§ñ Ollama Code Review

          **Summary:** $SUMMARY

          | Score | Issues | Recommendation |
          |-------|--------|----------------|
          | $SCORE/10 | $ISSUES | $REC |

          <details>
          <summary>Details</summary>

          \`\`\`json
          $(cat /tmp/review.json)
          \`\`\`
          </details>"
          
          EVENT="COMMENT"
          [[ "$REC" == "approve" ]] && EVENT="APPROVE"
          [[ "$REC" == "request_changes" ]] && EVENT="REQUEST_CHANGES"
          
          gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews \
            -f body="$BODY" -f event="$EVENT" || gh pr comment ${{ github.event.pull_request.number }} --body "$BODY"

      - name: Upload review artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: ollama-review
          path: /tmp/review.json
          retention-days: 1

  # ============================================
  # Self-Resolve - Process our own review (chains after initial-review)
  # ============================================
  self-resolve:
    name: Self-Resolve Issues
    needs: initial-review
    if: needs.initial-review.outputs.recommendation == 'request_changes'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
          token: ${{ secrets.CI_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Checkout PR branch
        env:
          HEAD_REF: ${{ github.head_ref }}
        run: git checkout "$HEAD_REF"

      - name: Download review artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          name: ollama-review
          path: /tmp

      - name: Analyze and resolve our own issues
        id: resolve
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Read our own review
          ISSUES=$(jq '.issues' /tmp/review.json)
          ISSUE_COUNT=$(echo "$ISSUES" | jq 'length')
          
          if [[ "$ISSUE_COUNT" == "0" ]]; then
            echo "No issues to resolve"
            echo "resolved=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "üìã Found $ISSUE_COUNT issues to analyze"
          
          # Get the diff for context
          gh pr diff ${{ github.event.pull_request.number }} --color=never > /tmp/diff.txt 2>/dev/null || true
          
          cat > /tmp/prompt.txt << 'EOF'
          You are resolving issues from your own code review. For each issue, determine:
          
          1. Is this a REAL issue that needs fixing? Or is it an INTENTIONAL change that should be acknowledged?
          2. If it needs fixing, provide exact old_content and new_content for search/replace
          3. If it's intentional (e.g., "file deleted" when deletion was the goal), mark as acknowledged
          
          Categories:
          - fix: Real issue, provide fix
          - acknowledge: Intentional change, no fix needed
          - dismiss: False positive or not actionable
          
          Respond with JSON:
          {
            "resolutions": [
              {
                "issue_description": "original issue",
                "category": "fix|acknowledge|dismiss", 
                "reason": "why this resolution",
                "file": "path if fix",
                "old_content": "if fix",
                "new_content": "if fix"
              }
            ],
            "summary": "overall summary",
            "all_resolved": true/false
          }
          
          ISSUES TO RESOLVE:
          EOF
          
          echo "$ISSUES" >> /tmp/prompt.txt
          echo -e "\n\nCURRENT DIFF:\n" >> /tmp/prompt.txt
          head -c 50000 /tmp/diff.txt >> /tmp/prompt.txt
          
          jq -n \
            --arg model "$OLLAMA_MODEL" \
            --rawfile prompt /tmp/prompt.txt \
            '{
              model: $model,
              messages: [
                { role: "system", content: "Self-resolving code review agent. Be practical - acknowledge intentional changes, fix real issues. JSON only." },
                { role: "user", content: $prompt }
              ],
              options: { temperature: 0.1, num_ctx: 131072, num_predict: 8192 },
              stream: false
            }' > /tmp/payload.json
          
          if curl -sf --max-time 300 \
            -H "Authorization: Bearer $OLLAMA_API_KEY" \
            -H "Content-Type: application/json" \
            -d @/tmp/payload.json \
            "$OLLAMA_HOST/api/chat" > /tmp/response.json; then
            jq -r '.message.content // empty' /tmp/response.json > /tmp/resolutions.json
          else
            echo '{"resolutions":[],"summary":"API error","all_resolved":false}' > /tmp/resolutions.json
          fi
          
          if ! jq empty /tmp/resolutions.json 2>/dev/null; then
            echo '{"resolutions":[],"summary":"Parse error","all_resolved":false}' > /tmp/resolutions.json
          fi
          
          FIX_COUNT=$(jq '[.resolutions[] | select(.category == "fix")] | length' /tmp/resolutions.json)
          ACK_COUNT=$(jq '[.resolutions[] | select(.category == "acknowledge")] | length' /tmp/resolutions.json)
          ALL_RESOLVED=$(jq -r '.all_resolved' /tmp/resolutions.json)
          
          echo "fix_count=$FIX_COUNT" >> $GITHUB_OUTPUT
          echo "ack_count=$ACK_COUNT" >> $GITHUB_OUTPUT
          echo "resolved=$ALL_RESOLVED" >> $GITHUB_OUTPUT

      - name: Apply fixes
        if: steps.resolve.outputs.fix_count != '0'
        run: |
          jq -c '.resolutions[] | select(.category == "fix")' /tmp/resolutions.json | while read -r fix; do
            FILE=$(echo "$fix" | jq -r '.file')
            OLD=$(echo "$fix" | jq -r '.old_content')
            NEW=$(echo "$fix" | jq -r '.new_content')
            
            [[ -z "$FILE" || "$FILE" == "null" ]] && continue
            [[ "$FILE" =~ \.\./|^/ ]] && continue
            [[ ! -f "$FILE" ]] && continue
            
            # Validate OLD is not empty (prevents file corruption)
            if [[ -z "$OLD" || "$OLD" == "null" ]]; then
              echo "‚ö†Ô∏è Skipping fix with empty old_content"
              continue
            fi
            
            if grep -qF "$OLD" "$FILE"; then
              # Use perl with environment variables to handle slashes in content
              OLD="$OLD" NEW="$NEW" perl -i -p0e 's/\Q$ENV{OLD}\E/$ENV{NEW}/s' "$FILE" && echo "‚úÖ Fixed: $FILE"
            fi
          done

      - name: Commit fixes
        if: steps.resolve.outputs.fix_count != '0'
        uses: stefanzweifel/git-auto-commit-action@04702edda442b2e678b25b537cec683a1493fcb9 # v7.1.0
        with:
          commit_message: "fix: self-resolve review issues (Ollama)"
          branch: ${{ github.head_ref }}

      - name: Post resolution summary
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          RESOLVED: ${{ steps.resolve.outputs.resolved }}
          FIX_COUNT: ${{ steps.resolve.outputs.fix_count }}
          ACK_COUNT: ${{ steps.resolve.outputs.ack_count }}
        run: |
          SUMMARY=$(jq -r '.summary' /tmp/resolutions.json)
          
          BODY="## üîÑ Self-Resolution Complete

          $SUMMARY

          | Resolution | Count |
          |------------|-------|
          | Fixes Applied | $FIX_COUNT |
          | Acknowledged (Intentional) | $ACK_COUNT |

          <details>
          <summary>Details</summary>

          \`\`\`json
          $(cat /tmp/resolutions.json)
          \`\`\`
          </details>"
          
          gh pr comment "$PR_NUMBER" --body "$BODY"
          
          # If all resolved, dismiss ALL our blocking reviews
          if [[ "$RESOLVED" == "true" ]]; then
            echo "‚úÖ All issues resolved - dismissing all blocking reviews"
            # Find ALL our blocking reviews and dismiss them
            REVIEW_IDS=$(gh api "repos/${{ github.repository }}/pulls/$PR_NUMBER/reviews" \
              --jq '[.[] | select(.user.login == "github-actions[bot]" and .state == "CHANGES_REQUESTED")] | .[].id')
            
            if [[ -n "$REVIEW_IDS" ]]; then
              for REVIEW_ID in $REVIEW_IDS; do
                echo "Dismissing review ID: $REVIEW_ID"
                gh api -X PUT "repos/${{ github.repository }}/pulls/$PR_NUMBER/reviews/$REVIEW_ID/dismissals" \
                  -f message="All issues have been resolved or acknowledged as intentional changes." || echo "‚ö†Ô∏è Could not dismiss review $REVIEW_ID"
              done
            else
              echo "No blocking reviews found to dismiss"
            fi
          fi

  # ============================================
  # Copilot Autofix - Fetch and apply security suggestions
  # ============================================
  copilot-autofix:
    name: Apply Copilot Autofix
    needs: initial-review
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      security-events: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
          token: ${{ secrets.CI_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Checkout PR branch
        env:
          HEAD_REF: ${{ github.head_ref }}
        run: git checkout "$HEAD_REF"

      - name: Fetch code scanning alerts with autofix
        id: alerts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get all open code scanning alerts for this PR's ref
          ALERTS=$(gh api repos/${{ github.repository }}/code-scanning/alerts \
            --jq '[.[] | select(.state == "open") | {number: .number, rule: .rule.id, file: .most_recent_instance.location.path}]' 2>/dev/null || echo '[]')
          
          echo "Found $(echo "$ALERTS" | jq 'length') open alerts"
          
          # Check each alert for autofix availability
          AUTOFIXES='[]'
          for alert_num in $(echo "$ALERTS" | jq -r '.[].number'); do
            echo "Checking alert #$alert_num for autofix..."
            
            AUTOFIX=$(gh api repos/${{ github.repository }}/code-scanning/alerts/$alert_num/autofix 2>/dev/null || echo '{}')
            
            if echo "$AUTOFIX" | jq -e '.status == "succeeded"' > /dev/null 2>&1; then
              echo "‚úÖ Autofix available for alert #$alert_num"
              AUTOFIXES=$(echo "$AUTOFIXES" | jq --argjson fix "$AUTOFIX" --arg num "$alert_num" '. + [{alert: ($num | tonumber), fix: $fix}]')
            fi
          done
          
          echo "$AUTOFIXES" > /tmp/autofixes.json
          FIX_COUNT=$(echo "$AUTOFIXES" | jq 'length')
          echo "fix_count=$FIX_COUNT" >> $GITHUB_OUTPUT
          echo "üìä Found $FIX_COUNT autofixes to evaluate"

      - name: Evaluate and apply autofixes
        if: steps.alerts.outputs.fix_count != '0'
        id: apply
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_REF: ${{ github.head_ref }}
        run: |
          # Use Ollama to evaluate each autofix suggestion
          cat > /tmp/prompt.txt << 'EOF'
          You are evaluating Copilot Autofix suggestions for code scanning alerts.
          For each autofix, determine if it should be applied:
          
          1. Is the fix safe and correct?
          2. Does it properly address the security issue?
          3. Will it break existing functionality?
          
          Respond with JSON:
          {
            "decisions": [
              {
                "alert": <number>,
                "apply": true/false,
                "reason": "why approve or reject"
              }
            ]
          }
          
          AUTOFIX SUGGESTIONS:
          EOF
          
          cat /tmp/autofixes.json >> /tmp/prompt.txt
          
          jq -n \
            --arg model "$OLLAMA_MODEL" \
            --rawfile prompt /tmp/prompt.txt \
            '{
              model: $model,
              messages: [
                { role: "system", content: "Security fix evaluator. Be conservative - only approve clearly safe fixes." },
                { role: "user", content: $prompt }
              ],
              options: { temperature: 0.1, num_ctx: 32768 },
              stream: false
            }' > /tmp/payload.json
          
          if curl -sf --max-time 120 \
            -H "Authorization: Bearer $OLLAMA_API_KEY" \
            -H "Content-Type: application/json" \
            -d @/tmp/payload.json \
            "$OLLAMA_HOST/api/chat" > /tmp/response.json; then
            jq -r '.message.content // empty' /tmp/response.json > /tmp/decisions.json
          else
            echo '{"decisions":[]}' > /tmp/decisions.json
          fi
          
          if ! jq empty /tmp/decisions.json 2>/dev/null; then
            echo '{"decisions":[]}' > /tmp/decisions.json
          fi
          
          # Apply approved autofixes via GitHub API
          APPLIED=0
          for row in $(jq -c '.decisions[] | select(.apply == true)' /tmp/decisions.json); do
            ALERT_NUM=$(echo "$row" | jq -r '.alert')
            echo "Applying autofix for alert #$ALERT_NUM..."
            
            # Use the autofix commit endpoint
            if gh api repos/${{ github.repository }}/code-scanning/alerts/$ALERT_NUM/autofix \
              -X POST \
              -f ref="refs/heads/$HEAD_REF" \
              -f message="fix: apply Copilot autofix for alert #$ALERT_NUM" 2>/dev/null; then
              echo "‚úÖ Applied autofix for alert #$ALERT_NUM"
              APPLIED=$((APPLIED + 1))
            else
              echo "‚ö†Ô∏è Could not apply autofix for alert #$ALERT_NUM"
            fi
          done
          
          echo "applied_count=$APPLIED" >> $GITHUB_OUTPUT

      - name: Post autofix summary
        if: steps.alerts.outputs.fix_count != '0'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FIX_COUNT=${{ steps.alerts.outputs.fix_count }}
          APPLIED=${{ steps.apply.outputs.applied_count || '0' }}
          
          BODY="## üîß Copilot Autofix Evaluation

          | Metric | Count |
          |--------|-------|
          | Autofixes Available | $FIX_COUNT |
          | Autofixes Applied | $APPLIED |

          <details>
          <summary>Evaluation Details</summary>

          \`\`\`json
          $(cat /tmp/decisions.json 2>/dev/null || echo '{}')
          \`\`\`
          </details>"
          
          gh pr comment ${{ github.event.pull_request.number }} --body "$BODY"

  # ============================================
  # Monitor AI Feedback - Triggered on any comment/review
  # ============================================
  monitor-ai-feedback:
    name: Monitor & Resolve AI Feedback
    if: |
      (github.event_name == 'pull_request_review' && 
       contains(fromJSON('["github-actions[bot]","gemini-code-assist[bot]","copilot[bot]","amazon-q-developer[bot]","coderabbitai[bot]","cursor[bot]","github-advanced-security[bot]"]'), github.actor)) ||
      (github.event_name == 'pull_request_review_comment' &&
       contains(fromJSON('["github-actions[bot]","gemini-code-assist[bot]","copilot[bot]","amazon-q-developer[bot]","coderabbitai[bot]","cursor[bot]","github-advanced-security[bot]"]'), github.event.comment.user.login)) ||
      (github.event_name == 'issue_comment' && 
       github.event.issue.pull_request &&
       contains(fromJSON('["github-actions[bot]","gemini-code-assist[bot]","copilot[bot]","amazon-q-developer[bot]","coderabbitai[bot]","cursor[bot]","github-advanced-security[bot]"]'), github.event.comment.user.login))
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    
    steps:
      - name: Check required secrets
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
        run: |
          if [[ -z "$OLLAMA_API_KEY" ]]; then
            echo "::error::OLLAMA_API_KEY secret is not configured"
            exit 1
          fi

      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Get PR number
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EVENT_NAME: ${{ github.event_name }}
          PR_NUMBER_FROM_PR: ${{ github.event.pull_request.number }}
          PR_NUMBER_FROM_ISSUE: ${{ github.event.issue.number }}
        run: |
          # Determine PR number based on event type
          if [[ "$EVENT_NAME" == "pull_request_review" ]] || [[ "$EVENT_NAME" == "pull_request_review_comment" ]]; then
            PR_NUM="$PR_NUMBER_FROM_PR"
          else
            PR_NUM="$PR_NUMBER_FROM_ISSUE"
          fi
          echo "number=$PR_NUM" >> $GITHUB_OUTPUT
          
          # Get PR head ref for checkout
          HEAD_REF=$(gh pr view "$PR_NUM" --json headRefName -q '.headRefName')
          echo "head_ref=$HEAD_REF" >> $GITHUB_OUTPUT

      - name: Checkout PR branch
        env:
          HEAD_REF: ${{ steps.pr.outputs.head_ref }}
        run: git checkout "$HEAD_REF"

      - name: Collect all AI feedback
        id: feedback
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ steps.pr.outputs.number }}
          
          # Get all unresolved review comments from AI agents
          gh api repos/${{ github.repository }}/pulls/$PR_NUM/comments \
            --jq '[.[] | select(.user.login | endswith("[bot]")) | {id: .id, user: .user.login, body: .body, path: .path, line: .line}]' > /tmp/review_comments.json || echo '[]' > /tmp/review_comments.json
          
          # Get all issue comments from AI agents, excluding our resolution summaries
          gh api repos/${{ github.repository }}/issues/$PR_NUM/comments \
            --jq '[.[] | select(
              (.user.login | endswith("[bot]")) and
              (.body | contains("## üîÑ AI Feedback Resolution") | not) and
              (.body | contains("## ‚úÖ All Checks Passed") | not)
            ) | {id: .id, user: .user.login, body: .body}]' > /tmp/issue_comments.json || echo '[]' > /tmp/issue_comments.json
          
          # Get reviews from AI agents
          gh api repos/${{ github.repository }}/pulls/$PR_NUM/reviews \
            --jq '[.[] | select(
              (.user.login | endswith("[bot]")) and 
              .state != "APPROVED" and
              (.body | contains("\"issues\":[]") | not)
            ) | {id: .id, user: .user.login, body: .body, state: .state}]' > /tmp/reviews.json || echo '[]' > /tmp/reviews.json
          
          # Combine all feedback
          jq -s 'map(select(. != null)) | add // []' /tmp/review_comments.json /tmp/issue_comments.json /tmp/reviews.json > /tmp/all_feedback.json
          
          ALREADY_PROCESSED=$(gh api repos/${{ github.repository }}/issues/$PR_NUM/comments \
            --jq "[.[] | select(.user.login == \"github-actions[bot]\" and (.body | contains(\"AI Feedback Resolution\"))) | .body] | length")
          
          if [[ "$ALREADY_PROCESSED" -gt 3 ]]; then
            echo "‚ö†Ô∏è Detected potential loop - stopping."
            echo "count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          FEEDBACK_COUNT=$(jq 'length' /tmp/all_feedback.json)
          echo "count=$FEEDBACK_COUNT" >> $GITHUB_OUTPUT

      - name: Analyze and generate fixes
        if: steps.feedback.outputs.count != '0'
        id: analyze
        env:
          OLLAMA_API_KEY: ${{ secrets.OLLAMA_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr diff ${{ steps.pr.outputs.number }} --color=never > /tmp/diff.txt
          
          cat > /tmp/prompt.txt << 'EOF'
          You are a code improvement agent. Analyze this AI reviewer feedback and generate fixes.
          Respond with JSON fixes only.
          EOF
          
          cat /tmp/all_feedback.json >> /tmp/prompt.txt
          echo -e "\n\nCURRENT DIFF:\n" >> /tmp/prompt.txt
          head -c 50000 /tmp/diff.txt >> /tmp/prompt.txt
          
          jq -n \
            --arg model "$OLLAMA_MODEL" \
            --rawfile prompt /tmp/prompt.txt \
            '{
              model: $model,
              messages: [
                { role: "system", content: "Code improvement agent. JSON only." },
                { role: "user", content: $prompt }
              ],
              options: { temperature: 0.1, num_ctx: 131072, num_predict: 8192 },
              stream: false
            }' > /tmp/payload.json
          
          if curl -sf --max-time 300 \
            -H "Authorization: Bearer $OLLAMA_API_KEY" \
            -H "Content-Type: application/json" \
            -d @/tmp/payload.json \
            "$OLLAMA_HOST/api/chat" > /tmp/response.json; then
            jq -r '.message.content // empty' /tmp/response.json > /tmp/fixes.json
          else
            echo '{"fixes":[],"summary":"API error"}' > /tmp/fixes.json
          fi

      - name: Apply fixes
        if: steps.analyze.outputs.fix_count != '0'
        run: |
          jq -c '.fixes[] | select(.action == "fix" and .safe_to_apply == true)' /tmp/fixes.json | while read -r fix; do
            FILE=$(echo "$fix" | jq -r '.file')
            OLD=$(echo "$fix" | jq -r '.old_content')
            NEW=$(echo "$fix" | jq -r '.new_content')
            
            [[ "$FILE" =~ \.\./|^/ ]] && continue
            [[ ! -f "$FILE" ]] && continue
            [[ -z "$OLD" || "$OLD" == "null" ]] && continue
            
            if grep -qF "$OLD" "$FILE"; then
              OLD="$OLD" NEW="$NEW" perl -i -p0e 's/\Q$ENV{OLD}\E/$ENV{NEW}/s' "$FILE"
            fi
          done

      - name: Commit fixes
        uses: stefanzweifel/git-auto-commit-action@04702edda442b2e678b25b537cec683a1493fcb9 # v7.1.0
        with:
          commit_message: "fix: resolve AI feedback (automated)"
          branch: ${{ steps.pr.outputs.head_ref }}

      - name: Post resolution summary
        if: steps.feedback.outputs.count != '0' && steps.analyze.outputs.fix_count != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr comment ${{ steps.pr.outputs.number }} --body "## üîÑ AI Feedback Resolution summary posted."

  # ============================================
  # Check if Ready to Merge
  # ============================================
  check-ready:
    name: Check Merge Readiness
    if: github.event_name == 'check_suite' && github.event.check_suite.conclusion == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Get associated PRs
        id: prs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api repos/${{ github.repository }}/commits/${{ github.event.check_suite.head_sha }}/pulls \
            --jq '.[0].number // empty' > /tmp/pr_num.txt
          echo "number=$(cat /tmp/pr_num.txt)" >> $GITHUB_OUTPUT

      - name: Check all conditions
        if: steps.prs.outputs.number != ''
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ steps.prs.outputs.number }}
          CI_STATUS=$(gh pr checks "$PR_NUM" --json state -q '[.[] | select(.state != "SUCCESS" and .state != "SKIPPED")] | length')
          BLOCKING=$(gh api repos/${{ github.repository }}/pulls/$PR_NUM/reviews \
            --jq '[.[] | select(.state == "CHANGES_REQUESTED")] | length')
          IS_DRAFT=$(gh pr view "$PR_NUM" --json isDraft -q '.isDraft')
          
          if [[ "$CI_STATUS" == "0" && "$BLOCKING" == "0" ]]; then
            echo "ready=true" >> $GITHUB_OUTPUT
          else
            echo "ready=false" >> $GITHUB_OUTPUT
          fi
          echo "is_draft=$IS_DRAFT" >> $GITHUB_OUTPUT

      - name: Auto-merge
        if: steps.check.outputs.ready == 'true' && steps.check.outputs.is_draft == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr merge ${{ steps.prs.outputs.number }} --squash --delete-branch

  # ============================================
  # Delegate to Google Jules for Complex Fixes
  # ============================================
  delegate-to-jules:
    name: Delegate to Google Jules
    needs: initial-review
    if: needs.initial-review.outputs.score < 5 && needs.initial-review.outputs.issues_count > 5
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Check for GOOGLE_JULES_API_KEY
        id: check_jules
        env:
          GOOGLE_JULES_API_KEY: ${{ secrets.GOOGLE_JULES_API_KEY }}
        run: |
          if [[ -z "$GOOGLE_JULES_API_KEY" ]]; then
            echo "::warning::GOOGLE_JULES_API_KEY not set."
            echo "available=false" >> $GITHUB_OUTPUT
          elif [[ ! "$GOOGLE_JULES_API_KEY" =~ ^[A-Za-z0-9_-]{30,}$ ]]; then
            echo "::error::GOOGLE_JULES_API_KEY format is invalid."
            echo "available=false" >> $GITHUB_OUTPUT
          else
            echo "available=true" >> $GITHUB_OUTPUT
          fi

      - name: Get PR details
        if: steps.check_jules.outputs.available == 'true'
        id: pr_details
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_JSON=$(gh pr view ${{ needs.initial-review.outputs.pr_number }} --json headRefName,body)
          echo "head_ref=$(echo "$PR_JSON" | jq -r '.headRefName')" >> $GITHUB_OUTPUT
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$(echo "$PR_JSON" | jq -r '.body')" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Jules Session
        if: steps.check_jules.outputs.available == 'true'
        id: jules
        env:
          GOOGLE_JULES_API_KEY: ${{ secrets.GOOGLE_JULES_API_KEY }}
          REPO_FULL_NAME: ${{ github.repository }}
          HEAD_REF: ${{ steps.pr_details.outputs.head_ref }}
          PR_BODY: ${{ steps.pr_details.outputs.body }}
          SCORE: ${{ needs.initial-review.outputs.score }}
          ISSUES_COUNT: ${{ needs.initial-review.outputs.issues_count }}
        run: |
          PROMPT="The code review score is low ($SCORE/10) with $ISSUES_COUNT issues. Please help fix this PR. Original PR body:\n\n$PR_BODY"
          
          JSON_PAYLOAD=$(jq -n \
            --arg prompt "$PROMPT" \
            --arg repo "$REPO_FULL_NAME" \
            --arg branch "$HEAD_REF" \
            '{
              prompt: $prompt,
              sourceContext: {
                source: "github",
                githubRepoContext: {
                  owner: ($repo | split("/")[0]),
                  repository: ($repo | split("/")[1]),
                  startingBranch: $branch
                }
              },
              automationMode: "AUTO_CREATE_PR"
            }')

          # Use timeout and retry for API call
          SESSION_RESPONSE=$(curl -s --max-time 30 --retry 3 -X POST "https://jules.googleapis.com/v1alpha/sessions" \
            -H "X-Goog-Api-Key: $GOOGLE_JULES_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD")

          SESSION_URL=$(echo "$SESSION_RESPONSE" | jq -r '.sessionUrl // empty')
          if [[ -z "$SESSION_URL" ]]; then
            echo "::error::Failed to create Jules session."
            exit 1
          fi
          echo "session_url=$SESSION_URL" >> $GITHUB_OUTPUT

      - name: Post Jules Session URL to PR
        if: steps.jules.outputs.session_url != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr comment ${{ needs.initial-review.outputs.pr_number }} --body "## ü§ñ Delegation to Google Jules Session: ${{ steps.jules.outputs.session_url }}"
