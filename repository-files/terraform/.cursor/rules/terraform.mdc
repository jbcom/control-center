---
description: Terraform/HCL coding standards
globs: ["**/*.tf", "**/*.tfvars"]
---

# Terraform Standards

## Style

- **Formatter**: `terraform fmt`
- **Linter**: `tflint`
- **Validator**: `terraform validate`

```bash
# Format
terraform fmt -recursive

# Validate
terraform validate

# Lint
tflint --recursive
```

## Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Resources | snake_case | `aws_instance.web_server` |
| Variables | snake_case | `instance_type` |
| Outputs | snake_case | `public_ip_address` |
| Modules | kebab-case | `module "vpc-network"` |
| Files | snake_case | `main.tf`, `variables.tf` |

```hcl
# ✅ Good
resource "aws_instance" "web_server" {
  instance_type = var.instance_type
}

# ❌ Bad
resource "aws_instance" "WebServer" {
  instance_type = var.instanceType
}
```

## File Organization

```
.
├── main.tf           # Primary resources
├── variables.tf      # Input variables
├── outputs.tf        # Output values
├── versions.tf       # Provider versions
├── locals.tf         # Local values
├── data.tf           # Data sources
└── modules/          # Local modules
```

### Example versions.tf

```hcl
terraform {
  required_version = ">= 1.5.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
```

## Variables

```hcl
# Always include description and type
variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}

# Use validation blocks for constraints
variable "environment" {
  description = "Deployment environment"
  type        = string

  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}
```

## Outputs

```hcl
# Always include description
output "instance_id" {
  description = "ID of the EC2 instance"
  value       = aws_instance.web_server.id
}

# Mark sensitive outputs
output "database_password" {
  description = "Database password"
  value       = random_password.db.result
  sensitive   = true
}
```

## Modules

```hcl
# Pin module versions
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"

  # Group required inputs first
  name = var.vpc_name
  cidr = var.vpc_cidr

  # Then optional inputs
  tags = var.tags
}
```

## State Management

```hcl
# Use remote backend
terraform {
  backend "s3" {
    bucket         = "terraform-state-bucket"
    key            = "project/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"
  }
}
```

## Security

- Never commit secrets to `.tfvars` files
- Use `sensitive = true` for secret outputs
- Use data sources for secrets (Vault, AWS SSM, etc.)
- Lock provider versions

```hcl
# Use data sources for secrets
data "aws_ssm_parameter" "db_password" {
  name = "/app/database/password"
}

resource "aws_db_instance" "main" {
  password = data.aws_ssm_parameter.db_password.value
}
```

## Testing

```bash
# Plan before apply
terraform plan -out=tfplan

# Apply with plan file
terraform apply tfplan

# Destroy with target
terraform destroy -target=aws_instance.test
```
