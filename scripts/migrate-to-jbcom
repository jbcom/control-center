#!/usr/bin/env bash
#
# migrate-to-jbcom - Full historical migration from jbdevprimary to jbcom org
#
# IDEMPOTENT: Can be run multiple times safely. Resumes where it left off.
#
# Usage:
#   ./scripts/migrate-to-jbcom [command] [options]
#
# Commands:
#   plan          Show what would be migrated (dry-run)
#   migrate       Execute the migration
#   privatize     Make sunset repos private
#   privatize-migrated  Make migrated source repos private
#   status        Show migration status
#
set -euo pipefail

# ==============================================================================
# CONFIGURATION
# ==============================================================================

SOURCE_ORG="jbdevprimary"
TARGET_ORG="jbcom"

# Repos already migrated to jbcom (skip these)
declare -a ALREADY_MIGRATED=(
  "control-center"
  "agentic-triage"
)

# Repos to SUNSET (make private, don't migrate)
declare -a SUNSET_REPOS=(
  "jbcom-oss-ecosystem"
  "chef-selenium-grid-extras"
  "hamachi-vpn"
  "openapi-31-to-30-converter"
)

# Migration mapping: source_name:target_name
declare -a MIGRATION_MAP=(
  # Python
  "agentic-crew:python-agentic-crew"
  "vendor-connectors:python-vendor-connectors"
  "extended-data-types:python-extended-data-types"
  "directed-inputs-class:python-directed-inputs-class"
  "lifecyclelogging:python-lifecyclelogging"
  "python-terraform-bridge:python-terraform-bridge"
  "rivers-of-reckoning:python-rivers-of-reckoning"
  "ai_game_dev:python-ai-game-dev"
  # Node.js
  "agentic-control:nodejs-agentic-control"
  "strata:nodejs-strata"
  "otter-river-rush:nodejs-otter-river-rush"
  "otterfall:nodejs-otterfall"
  "rivermarsh:nodejs-rivermarsh"
  "pixels-pygame-palace:nodejs-pixels-pygame-palace"
  # Go
  "port-api:go-port-api"
  "secretsync:go-secretsync"
  "vault-secret-sync:go-vault-secret-sync"
  # Terraform
  "terraform-github-markdown:terraform-github-markdown"
  "terraform-repository-automation:terraform-repository-automation"
)

# ==============================================================================
# HELPERS
# ==============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}â„¹${NC} $*"; }
log_success() { echo -e "${GREEN}âœ“${NC} $*"; }
log_warn() { echo -e "${YELLOW}âš ${NC} $*"; }
log_error() { echo -e "${RED}âœ—${NC} $*" >&2; }

repo_exists() {
  gh api "/repos/${1}/${2}" &>/dev/null
}

# Check if repo has commits (not empty)
repo_has_commits() {
  local org="$1" repo="$2"
  local count
  count=$(gh api "/repos/${org}/${repo}/commits?per_page=1" -q 'length' 2>/dev/null || echo "0")
  [[ "$count" -gt 0 ]]
}

get_repo_description() {
  gh api "/repos/${1}/${2}" -q '.description // ""' 2>/dev/null || echo ""
}

get_repo_visibility() {
  gh api "/repos/${1}/${2}" -q '.visibility' 2>/dev/null || echo "unknown"
}

get_default_branch() {
  gh api "/repos/${1}/${2}" -q '.default_branch' 2>/dev/null || echo "main"
}

# ==============================================================================
# COMMANDS
# ==============================================================================

cmd_plan() {
  echo "=============================================="
  echo "  Migration Plan: ${SOURCE_ORG} â†’ ${TARGET_ORG}"
  echo "=============================================="
  echo ""
  
  echo "ðŸ“¦ REPOS TO MIGRATE:"
  echo "--------------------"
  local migrate_count=0 needs_push=0
  for mapping in "${MIGRATION_MAP[@]}"; do
    local source="${mapping%%:*}"
    local target="${mapping#*:}"
    local status=""
    
    if ! repo_exists "$SOURCE_ORG" "$source"; then
      status="${RED}(source not found)${NC}"
    elif repo_exists "$TARGET_ORG" "$target"; then
      if repo_has_commits "$TARGET_ORG" "$target"; then
        status="${GREEN}(done)${NC}"
      else
        status="${YELLOW}(exists but empty - needs push)${NC}"
        needs_push=$((needs_push + 1))
      fi
    else
      status="${BLUE}(ready)${NC}"
      migrate_count=$((migrate_count + 1))
    fi
    
    printf "  %-35s â†’ %-40s %b\n" "$source" "$target" "$status"
  done
  echo ""
  echo "  New repos to create: $migrate_count"
  echo "  Empty repos to push: $needs_push"
  echo ""
  
  echo "ðŸŒ… REPOS TO SUNSET:"
  echo "-------------------"
  for repo in "${SUNSET_REPOS[@]}"; do
    local vis
    vis=$(get_repo_visibility "$SOURCE_ORG" "$repo")
    if [[ "$vis" == "private" ]]; then
      echo -e "  $repo ${GREEN}(already private)${NC}"
    elif [[ "$vis" == "unknown" ]]; then
      echo -e "  $repo ${RED}(not found)${NC}"
    else
      echo -e "  $repo ${YELLOW}(public â†’ private)${NC}"
    fi
  done
  echo ""
  
  echo "âœ… ALREADY MIGRATED:"
  echo "--------------------"
  for repo in "${ALREADY_MIGRATED[@]}"; do
    if repo_exists "$TARGET_ORG" "$repo"; then
      echo -e "  $repo ${GREEN}(exists)${NC}"
    else
      echo -e "  $repo ${RED}(missing)${NC}"
    fi
  done
  echo ""
}

cmd_migrate() {
  local dry_run="${1:-}"
  [[ "$dry_run" == "--dry-run" ]] && log_info "DRY RUN MODE" && echo ""
  
  local token="${GITHUB_TOKEN:-${GH_TOKEN:-}}"
  if [[ -z "$token" ]]; then
    log_error "GITHUB_TOKEN or GH_TOKEN required"
    exit 1
  fi
  
  local success=0 skip=0 fail=0
  
  for mapping in "${MIGRATION_MAP[@]}"; do
    local source="${mapping%%:*}"
    local target="${mapping#*:}"
    
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "  $source â†’ $target"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    # Check source
    if ! repo_exists "$SOURCE_ORG" "$source"; then
      log_error "Source not found: ${SOURCE_ORG}/${source}"
      fail=$((fail + 1))
      continue
    fi
    
    # Check target state
    local needs_create=false needs_push=false
    if repo_exists "$TARGET_ORG" "$target"; then
      if repo_has_commits "$TARGET_ORG" "$target"; then
        log_success "Already migrated - skipping"
        skip=$((skip + 1))
        continue
      else
        log_info "Repo exists but empty - will push"
        needs_push=true
      fi
    else
      needs_create=true
      needs_push=true
    fi
    
    if [[ "$dry_run" == "--dry-run" ]]; then
      $needs_create && log_info "[DRY] Would create ${TARGET_ORG}/${target}"
      $needs_push && log_info "[DRY] Would push content"
      success=$((success + 1))
      continue
    fi
    
    # Create repo if needed
    if $needs_create; then
      local desc
      desc=$(get_repo_description "$SOURCE_ORG" "$source")
      log_info "Creating ${TARGET_ORG}/${target}"
      if ! gh repo create "${TARGET_ORG}/${target}" --public --description "${desc}" 2>/dev/null; then
        log_error "Failed to create repo"
        fail=$((fail + 1))
        continue
      fi
      log_success "Created"
    fi
    
    # Push content
    if $needs_push; then
      local tmp_dir
      tmp_dir=$(mktemp -d)
      
      log_info "Cloning ${SOURCE_ORG}/${source}"
      if ! git clone --bare "https://${token}@github.com/${SOURCE_ORG}/${source}.git" "${tmp_dir}/repo.git" 2>&1 | grep -v "^remote:"; then
        log_error "Clone failed"
        rm -rf "$tmp_dir"
        fail=$((fail + 1))
        continue
      fi
      
      cd "${tmp_dir}/repo.git"
      
      # Push all branches and tags (NOT --mirror, which includes PR refs)
      log_info "Pushing branches and tags"
      local push_failed=false
      
      if ! git push "https://${token}@github.com/${TARGET_ORG}/${target}.git" --all 2>&1 | grep -v "^remote:"; then
        log_warn "Push --all had issues"
        push_failed=true
      fi
      
      if ! git push "https://${token}@github.com/${TARGET_ORG}/${target}.git" --tags 2>&1 | grep -v "^remote:"; then
        log_warn "Push --tags had issues"
      fi
      
      cd /workspace
      rm -rf "$tmp_dir"
      
      # Verify push succeeded
      if repo_has_commits "$TARGET_ORG" "$target"; then
        log_success "Migrated successfully"
        success=$((success + 1))
      else
        log_error "Push failed - target still empty"
        fail=$((fail + 1))
      fi
    fi
    
    echo ""
  done
  
  echo "=============================================="
  echo "  Summary"
  echo "=============================================="
  echo -e "  ${GREEN}Success:${NC} $success"
  echo -e "  ${YELLOW}Skipped:${NC} $skip"
  echo -e "  ${RED}Failed:${NC}  $fail"
  echo ""
}

cmd_privatize() {
  local dry_run="${1:-}"
  [[ "$dry_run" == "--dry-run" ]] && log_info "DRY RUN" && echo ""
  
  echo "Making sunset repos private..."
  echo ""
  
  for repo in "${SUNSET_REPOS[@]}"; do
    local vis
    vis=$(get_repo_visibility "$SOURCE_ORG" "$repo")
    
    if [[ "$vis" == "private" ]]; then
      log_success "$repo - already private"
    elif [[ "$vis" == "unknown" ]]; then
      log_warn "$repo - not found"
    elif [[ "$dry_run" == "--dry-run" ]]; then
      log_info "[DRY] Would make private: $repo"
    else
      log_info "Making private: $repo"
      if gh repo edit "${SOURCE_ORG}/${repo}" --visibility private 2>/dev/null; then
        log_success "Done"
      else
        log_error "Failed"
      fi
    fi
  done
  echo ""
}

cmd_privatize_migrated() {
  local dry_run="${1:-}"
  [[ "$dry_run" == "--dry-run" ]] && log_info "DRY RUN" && echo ""
  
  echo "Making migrated source repos private..."
  echo ""
  
  for mapping in "${MIGRATION_MAP[@]}"; do
    local source="${mapping%%:*}"
    local target="${mapping#*:}"
    
    # Only privatize if migration is complete
    if ! repo_exists "$TARGET_ORG" "$target" || ! repo_has_commits "$TARGET_ORG" "$target"; then
      log_warn "$source - target not ready, skipping"
      continue
    fi
    
    local vis
    vis=$(get_repo_visibility "$SOURCE_ORG" "$source")
    
    if [[ "$vis" == "private" ]]; then
      log_success "$source - already private"
    elif [[ "$dry_run" == "--dry-run" ]]; then
      log_info "[DRY] Would make private: $source"
    else
      log_info "Making private: $source"
      if gh repo edit "${SOURCE_ORG}/${source}" --visibility private 2>/dev/null; then
        log_success "Done"
      else
        log_error "Failed"
      fi
    fi
  done
  echo ""
}

cmd_status() {
  echo "=============================================="
  echo "  Migration Status"
  echo "=============================================="
  echo ""
  
  local done=0 empty=0 pending=0 sunset=0
  
  for mapping in "${MIGRATION_MAP[@]}"; do
    local target="${mapping#*:}"
    if repo_exists "$TARGET_ORG" "$target"; then
      if repo_has_commits "$TARGET_ORG" "$target"; then
        done=$((done + 1))
      else
        empty=$((empty + 1))
      fi
    else
      pending=$((pending + 1))
    fi
  done
  
  for repo in "${SUNSET_REPOS[@]}"; do
    [[ "$(get_repo_visibility "$SOURCE_ORG" "$repo")" == "private" ]] && sunset=$((sunset + 1))
  done
  
  echo "  Fully migrated:     $done / ${#MIGRATION_MAP[@]}"
  echo "  Empty (need push):  $empty"
  echo "  Not started:        $pending"
  echo "  Sunset (private):   $sunset / ${#SUNSET_REPOS[@]}"
  echo ""
}

show_help() {
  cat << EOF
Usage: $(basename "$0") <command> [options]

Commands:
  plan                    Show migration plan
  migrate [--dry-run]     Execute migration (idempotent)
  privatize [--dry-run]   Make sunset repos private
  privatize-migrated      Make migrated source repos private
  status                  Show status

Source: ${SOURCE_ORG}
Target: ${TARGET_ORG}
EOF
}

main() {
  local cmd="${1:-}"
  shift || true
  
  case "$cmd" in
    plan) cmd_plan ;;
    migrate) cmd_migrate "$@" ;;
    privatize) cmd_privatize "$@" ;;
    privatize-migrated) cmd_privatize_migrated "$@" ;;
    status) cmd_status ;;
    -h|--help|help|"") show_help ;;
    *) log_error "Unknown: $cmd"; show_help; exit 1 ;;
  esac
}

main "$@"
