#!/usr/bin/env bash
#
# migrate-to-jbcom - Full historical migration from jbdevprimary to jbcom org
#
# IDEMPOTENT: Can be run multiple times safely. Resumes where it left off.
#
# Usage:
#   ./scripts/migrate-to-jbcom [command] [options]
#
# Commands:
#   plan          Show what would be migrated (dry-run)
#   migrate       Execute the migration
#   privatize     Make sunset repos private
#   privatize-migrated  Make migrated source repos private
#   status        Show migration status
#
set -euo pipefail

# ==============================================================================
# CONFIGURATION
# ==============================================================================

SOURCE_ORG="jbdevprimary"
TARGET_ORG="jbcom"

# Repos already migrated to jbcom (skip these)
declare -a ALREADY_MIGRATED=(
  "control-center"
  "agentic-triage"
)

# Repos to SUNSET (make private, don't migrate)
declare -a SUNSET_REPOS=(
  "jbcom-oss-ecosystem"
  "chef-selenium-grid-extras"
  "hamachi-vpn"
  "openapi-31-to-30-converter"
)

# Migration mapping: source_name:target_name
declare -a MIGRATION_MAP=(
  # Python
  "agentic-crew:python-agentic-crew"
  "vendor-connectors:python-vendor-connectors"
  "extended-data-types:python-extended-data-types"
  "directed-inputs-class:python-directed-inputs-class"
  "lifecyclelogging:python-lifecyclelogging"
  "python-terraform-bridge:python-terraform-bridge"
  "rivers-of-reckoning:python-rivers-of-reckoning"
  "ai_game_dev:python-ai-game-dev"
  # Node.js
  "agentic-control:nodejs-agentic-control"
  "strata:nodejs-strata"
  "otter-river-rush:nodejs-otter-river-rush"
  "otterfall:nodejs-otterfall"
  "rivermarsh:nodejs-rivermarsh"
  "pixels-pygame-palace:nodejs-pixels-pygame-palace"
  # Go
  "port-api:go-port-api"
  "secretsync:go-secretsync"
  "vault-secret-sync:go-vault-secret-sync"
  # Terraform
  "terraform-github-markdown:terraform-github-markdown"
  "terraform-repository-automation:terraform-repository-automation"
)

# GitHub Projects to migrate (org-level projects)
# Format: "source_project_name:target_project_name"
declare -a PROJECT_MAP=(
  "Ecosystem Integration:Ecosystem"
  "Ecosystem Roadmap:Roadmap"
)

# ==============================================================================
# HELPERS
# ==============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}â„¹${NC} $*"; }
log_success() { echo -e "${GREEN}âœ“${NC} $*"; }
log_warn() { echo -e "${YELLOW}âš ${NC} $*"; }
log_error() { echo -e "${RED}âœ—${NC} $*" >&2; }

repo_exists() {
  gh api "/repos/${1}/${2}" &>/dev/null
}

# Check if repo has commits (not empty)
repo_has_commits() {
  local org="$1" repo="$2"
  local response
  response=$(gh api "/repos/${org}/${repo}/commits?per_page=1" 2>/dev/null || echo "[]")
  # Check if it's an array with items (not error JSON)
  if echo "$response" | jq -e 'type == "array" and length > 0' &>/dev/null; then
    return 0
  fi
  return 1
}

get_repo_description() {
  gh api "/repos/${1}/${2}" -q '.description // ""' 2>/dev/null || echo ""
}

get_repo_visibility() {
  gh api "/repos/${1}/${2}" -q '.visibility' 2>/dev/null || echo "unknown"
}

get_default_branch() {
  gh api "/repos/${1}/${2}" -q '.default_branch' 2>/dev/null || echo "main"
}

# Check if repo is archived
is_repo_archived() {
  local org="$1" repo="$2"
  [[ "$(gh api "/repos/${org}/${repo}" -q '.archived' 2>/dev/null)" == "true" ]]
}

# Make repo private, handling archived repos (unarchive â†’ private â†’ re-archive)
make_repo_private() {
  local org="$1" repo="$2"
  local was_archived=false

  if is_repo_archived "$org" "$repo"; then
    was_archived=true
    gh api -X PATCH "/repos/${org}/${repo}" -f archived=false >/dev/null 2>&1 || return 1
  fi

  if ! gh repo edit "${org}/${repo}" --visibility private --accept-visibility-change-consequences >/dev/null 2>&1; then
    [[ "$was_archived" == "true" ]] && gh api -X PATCH "/repos/${org}/${repo}" -f archived=true >/dev/null 2>&1
    return 1
  fi

  [[ "$was_archived" == "true" ]] && gh api -X PATCH "/repos/${org}/${repo}" -f archived=true >/dev/null 2>&1
  return 0
}

# ==============================================================================
# COMMANDS
# ==============================================================================

cmd_plan() {
  echo "=============================================="
  echo "  Migration Plan: ${SOURCE_ORG} â†’ ${TARGET_ORG}"
  echo "=============================================="
  echo ""

  echo "ðŸ“¦ REPOS TO MIGRATE:"
  echo "--------------------"
  local migrate_count=0 needs_push=0
  for mapping in "${MIGRATION_MAP[@]}"; do
    local source="${mapping%%:*}"
    local target="${mapping#*:}"
    local status=""

    if ! repo_exists "$SOURCE_ORG" "$source"; then
      status="${RED}(source not found)${NC}"
    elif repo_exists "$TARGET_ORG" "$target"; then
      if repo_has_commits "$TARGET_ORG" "$target"; then
        status="${GREEN}(done)${NC}"
      else
        status="${YELLOW}(exists but empty - needs push)${NC}"
        needs_push=$((needs_push + 1))
      fi
    else
      status="${BLUE}(ready)${NC}"
      migrate_count=$((migrate_count + 1))
    fi

    printf "  %-35s â†’ %-40s %b\n" "$source" "$target" "$status"
  done
  echo ""
  echo "  New repos to create: $migrate_count"
  echo "  Empty repos to push: $needs_push"
  echo ""

  echo "ðŸŒ… REPOS TO SUNSET:"
  echo "-------------------"
  for repo in "${SUNSET_REPOS[@]}"; do
    local vis
    vis=$(get_repo_visibility "$SOURCE_ORG" "$repo")
    if [[ "$vis" == "private" ]]; then
      echo -e "  $repo ${GREEN}(already private)${NC}"
    elif [[ "$vis" == "unknown" ]]; then
      echo -e "  $repo ${RED}(not found)${NC}"
    else
      echo -e "  $repo ${YELLOW}(public â†’ private)${NC}"
    fi
  done
  echo ""

  echo "âœ… ALREADY MIGRATED:"
  echo "--------------------"
  for repo in "${ALREADY_MIGRATED[@]}"; do
    if repo_exists "$TARGET_ORG" "$repo"; then
      echo -e "  $repo ${GREEN}(exists)${NC}"
    else
      echo -e "  $repo ${RED}(missing)${NC}"
    fi
  done
  echo ""
}

cmd_migrate() {
  local dry_run="${1:-}"
  [[ "$dry_run" == "--dry-run" ]] && log_info "DRY RUN MODE" && echo ""

  local token="${GITHUB_TOKEN:-${GH_TOKEN:-}}"
  if [[ -z "$token" ]]; then
    log_error "GITHUB_TOKEN or GH_TOKEN required"
    exit 1
  fi

  local success=0 skip=0 fail=0

  for mapping in "${MIGRATION_MAP[@]}"; do
    local source="${mapping%%:*}"
    local target="${mapping#*:}"

    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "  $source â†’ $target"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    # Check source
    if ! repo_exists "$SOURCE_ORG" "$source"; then
      log_error "Source not found: ${SOURCE_ORG}/${source}"
      fail=$((fail + 1))
      continue
    fi

    # Check target state
    local needs_create=false needs_push=false
    if repo_exists "$TARGET_ORG" "$target"; then
      if repo_has_commits "$TARGET_ORG" "$target"; then
        log_success "Already migrated - skipping"
        skip=$((skip + 1))
        continue
      else
        log_info "Repo exists but empty - will push"
        needs_push=true
      fi
    else
      needs_create=true
      needs_push=true
    fi

    if [[ "$dry_run" == "--dry-run" ]]; then
      $needs_create && log_info "[DRY] Would create ${TARGET_ORG}/${target}"
      $needs_push && log_info "[DRY] Would push content"
      success=$((success + 1))
      continue
    fi

    # Create repo if needed
    if $needs_create; then
      local desc
      desc=$(get_repo_description "$SOURCE_ORG" "$source")
      log_info "Creating ${TARGET_ORG}/${target}"
      if ! gh repo create "${TARGET_ORG}/${target}" --public --description "${desc}" 2>/dev/null; then
        log_error "Failed to create repo"
        fail=$((fail + 1))
        continue
      fi
      log_success "Created"
    fi

    # Push content
    if $needs_push; then
      local tmp_dir
      tmp_dir=$(mktemp -d)

      log_info "Cloning ${SOURCE_ORG}/${source}"
      if ! git clone --bare "https://${token}@github.com/${SOURCE_ORG}/${source}.git" "${tmp_dir}/repo.git" 2>&1 | grep -v "^remote:"; then
        log_error "Clone failed"
        rm -rf "$tmp_dir"
        fail=$((fail + 1))
        continue
      fi

      cd "${tmp_dir}/repo.git"

      # Push all branches and tags (NOT --mirror, which includes PR refs)
      log_info "Pushing branches and tags"
      local push_failed=false

      if ! git push "https://${token}@github.com/${TARGET_ORG}/${target}.git" --all 2>&1 | grep -v "^remote:"; then
        log_warn "Push --all had issues"
        push_failed=true
      fi

      if ! git push "https://${token}@github.com/${TARGET_ORG}/${target}.git" --tags 2>&1 | grep -v "^remote:"; then
        log_warn "Push --tags had issues"
      fi

      cd /workspace
      rm -rf "$tmp_dir"

      # Verify push succeeded
      if repo_has_commits "$TARGET_ORG" "$target"; then
        log_success "Migrated successfully"
        success=$((success + 1))
      else
        log_error "Push failed - target still empty"
        fail=$((fail + 1))
      fi
    fi

    echo ""
  done

  echo "=============================================="
  echo "  Summary"
  echo "=============================================="
  echo -e "  ${GREEN}Success:${NC} $success"
  echo -e "  ${YELLOW}Skipped:${NC} $skip"
  echo -e "  ${RED}Failed:${NC}  $fail"
  echo ""
}

cmd_privatize() {
  local dry_run="${1:-}"
  [[ "$dry_run" == "--dry-run" ]] && log_info "DRY RUN" && echo ""

  echo "Making sunset repos private..."
  echo ""

  for repo in "${SUNSET_REPOS[@]}"; do
    local vis
    vis=$(get_repo_visibility "$SOURCE_ORG" "$repo")

    if [[ "$vis" == "private" ]]; then
      log_success "$repo - already private"
    elif [[ "$vis" == "unknown" ]]; then
      log_warn "$repo - not found"
    elif [[ "$dry_run" == "--dry-run" ]]; then
      log_info "[DRY] Would make private: $repo"
    else
      log_info "Making private: $repo"
      if make_repo_private "$SOURCE_ORG" "$repo"; then
        log_success "Done"
      else
        log_error "Failed"
      fi
    fi
  done
  echo ""
}

cmd_privatize_migrated() {
  local dry_run="${1:-}"
  [[ "$dry_run" == "--dry-run" ]] && log_info "DRY RUN" && echo ""

  echo "Making migrated source repos private..."
  echo ""

  for mapping in "${MIGRATION_MAP[@]}"; do
    local source="${mapping%%:*}"
    local target="${mapping#*:}"

    # Only privatize if migration is complete
    if ! repo_exists "$TARGET_ORG" "$target" || ! repo_has_commits "$TARGET_ORG" "$target"; then
      log_warn "$source - target not ready, skipping"
      continue
    fi

    local vis
    vis=$(get_repo_visibility "$SOURCE_ORG" "$source")

    if [[ "$vis" == "private" ]]; then
      log_success "$source - already private"
    elif [[ "$dry_run" == "--dry-run" ]]; then
      log_info "[DRY] Would make private: $source"
    else
      log_info "Making private: $source"
      if make_repo_private "$SOURCE_ORG" "$source"; then
        log_success "Done"
      else
        log_error "Failed"
      fi
    fi
  done
  echo ""
}

# Migrate open PRs from source to target (idempotent)
migrate_prs_for_repo() {
  local source="$1" target="$2" dry_run="${3:-}"
  local created=0 skipped=0 failed=0

  # Get open PRs from source
  local prs
  prs=$(gh api "/repos/${SOURCE_ORG}/${source}/pulls?state=open&per_page=100" \
    -q '.[] | @base64' 2>/dev/null || echo "")

  if [[ -z "$prs" ]]; then
    log_info "No open PRs in source"
    return 0
  fi

  for pr_b64 in $prs; do
    local pr_json
    pr_json=$(echo "$pr_b64" | base64 -d)

    local pr_num head_ref base_ref title body
    pr_num=$(echo "$pr_json" | jq -r '.number')
    head_ref=$(echo "$pr_json" | jq -r '.head.ref')
    base_ref=$(echo "$pr_json" | jq -r '.base.ref')
    title=$(echo "$pr_json" | jq -r '.title')
    body=$(echo "$pr_json" | jq -r '.body // ""')

    echo "  PR #${pr_num}: ${title:0:50}..."

    # IDEMPOTENT CHECK 1: Does target PR already exist with same title?
    local existing_by_title
    existing_by_title=$(gh api "/repos/${TARGET_ORG}/${target}/pulls?state=all&per_page=100" \
      -q ".[] | select(.title == \"${title}\") | .number" 2>/dev/null | head -1 || echo "")
    if [[ -n "$existing_by_title" ]]; then
      log_success "    Already exists as #${existing_by_title} - skip"
      skipped=$((skipped + 1))
      continue
    fi

    # IDEMPOTENT CHECK 2: Does target have open PR with same head branch?
    local existing_by_branch
    existing_by_branch=$(gh api "/repos/${TARGET_ORG}/${target}/pulls?state=open&head=${TARGET_ORG}:${head_ref}" \
      -q '.[0].number' 2>/dev/null || echo "")
    if [[ -n "$existing_by_branch" && "$existing_by_branch" != "null" ]]; then
      log_success "    Branch ${head_ref} has PR #${existing_by_branch} - skip"
      skipped=$((skipped + 1))
      continue
    fi

    # Check if head branch exists in target
    if ! gh api "/repos/${TARGET_ORG}/${target}/branches/${head_ref}" &>/dev/null; then
      log_warn "    Branch ${head_ref} missing in target - skip"
      failed=$((failed + 1))
      continue
    fi

    # Check if base branch exists
    if ! gh api "/repos/${TARGET_ORG}/${target}/branches/${base_ref}" &>/dev/null; then
      log_warn "    Base ${base_ref} missing - skip"
      failed=$((failed + 1))
      continue
    fi

    if [[ "$dry_run" == "--dry-run" ]]; then
      log_info "    [DRY] Would create PR"
      created=$((created + 1))
      continue
    fi

    # Create PR
    local new_body="*Migrated from [${SOURCE_ORG}/${source}#${pr_num}](https://github.com/${SOURCE_ORG}/${source}/pull/${pr_num})*

---

${body}"

    if gh pr create \
      --repo "${TARGET_ORG}/${target}" \
      --head "${head_ref}" \
      --base "${base_ref}" \
      --title "${title}" \
      --body "${new_body}" 2>/dev/null; then
      log_success "    Created"
      created=$((created + 1))
    else
      log_error "    Failed to create"
      failed=$((failed + 1))
    fi
  done

  echo "    PRs: ${created} created, ${skipped} skipped, ${failed} failed"
}

# Migrate issues from source to target (idempotent)
migrate_issues_for_repo() {
  local source="$1" target="$2" dry_run="${3:-}"
  local created=0 skipped=0 failed=0

  # Get open issues (excluding PRs) from source
  local issues
  issues=$(gh api "/repos/${SOURCE_ORG}/${source}/issues?state=open&per_page=100" \
    -q '.[] | select(.pull_request == null) | @base64' 2>/dev/null || echo "")

  if [[ -z "$issues" ]]; then
    log_info "No open issues in source"
    return 0
  fi

  for issue_b64 in $issues; do
    local issue_json
    issue_json=$(echo "$issue_b64" | base64 -d)

    local issue_num title body labels_json
    issue_num=$(echo "$issue_json" | jq -r '.number')
    title=$(echo "$issue_json" | jq -r '.title')
    body=$(echo "$issue_json" | jq -r '.body // ""')
    labels_json=$(echo "$issue_json" | jq -r '[.labels[].name] | join(",")')

    echo "  Issue #${issue_num}: ${title:0:50}..."

    # IDEMPOTENT CHECK: Does target issue already exist with same title?
    local existing
    existing=$(gh api "/repos/${TARGET_ORG}/${target}/issues?state=all&per_page=100" \
      -q ".[] | select(.pull_request == null) | select(.title == \"${title}\") | .number" 2>/dev/null | head -1 || echo "")
    if [[ -n "$existing" ]]; then
      log_success "    Already exists as #${existing} - skip"
      skipped=$((skipped + 1))
      continue
    fi

    if [[ "$dry_run" == "--dry-run" ]]; then
      log_info "    [DRY] Would create issue"
      created=$((created + 1))
      continue
    fi

    # Create issue
    local new_body="*Migrated from [${SOURCE_ORG}/${source}#${issue_num}](https://github.com/${SOURCE_ORG}/${source}/issues/${issue_num})*

---

${body}"

    local label_args=""
    if [[ -n "$labels_json" && "$labels_json" != "null" ]]; then
      for label in $(echo "$labels_json" | tr ',' '\n'); do
        label_args="$label_args --label $label"
      done
    fi

    if gh issue create \
      --repo "${TARGET_ORG}/${target}" \
      --title "${title}" \
      --body "${new_body}" \
      $label_args 2>/dev/null; then
      log_success "    Created"
      created=$((created + 1))
    else
      log_error "    Failed to create"
      failed=$((failed + 1))
    fi
  done

  echo "    Issues: ${created} created, ${skipped} skipped, ${failed} failed"
}

cmd_migrate_prs() {
  local dry_run="${1:-}"
  [[ "$dry_run" == "--dry-run" ]] && log_info "DRY RUN MODE" && echo ""

  echo "=============================================="
  echo "  Migrating PRs: ${SOURCE_ORG} â†’ ${TARGET_ORG}"
  echo "=============================================="
  echo ""

  for mapping in "${MIGRATION_MAP[@]}"; do
    local source="${mapping%%:*}"
    local target="${mapping#*:}"

    # Only migrate PRs if target repo exists and has commits
    if ! repo_exists "$TARGET_ORG" "$target"; then
      log_warn "$target - repo doesn't exist, skipping PRs"
      continue
    fi

    if ! repo_has_commits "$TARGET_ORG" "$target"; then
      log_warn "$target - repo empty, skipping PRs"
      continue
    fi

    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "  ${source} â†’ ${target}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    migrate_prs_for_repo "$source" "$target" "$dry_run"
    echo ""
  done
}

cmd_migrate_issues() {
  local dry_run="${1:-}"
  [[ "$dry_run" == "--dry-run" ]] && log_info "DRY RUN MODE" && echo ""

  echo "=============================================="
  echo "  Migrating Issues: ${SOURCE_ORG} â†’ ${TARGET_ORG}"
  echo "=============================================="
  echo ""

  for mapping in "${MIGRATION_MAP[@]}"; do
    local source="${mapping%%:*}"
    local target="${mapping#*:}"

    # Only migrate issues if target repo exists
    if ! repo_exists "$TARGET_ORG" "$target"; then
      log_warn "$target - repo doesn't exist, skipping issues"
      continue
    fi

    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "  ${source} â†’ ${target}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    migrate_issues_for_repo "$source" "$target" "$dry_run"
    echo ""
  done
}

cmd_status() {
  echo "=============================================="
  echo "  Migration Status"
  echo "=============================================="
  echo ""

  local done=0 empty=0 pending=0 sunset=0

  for mapping in "${MIGRATION_MAP[@]}"; do
    local target="${mapping#*:}"
    if repo_exists "$TARGET_ORG" "$target"; then
      if repo_has_commits "$TARGET_ORG" "$target"; then
        done=$((done + 1))
      else
        empty=$((empty + 1))
      fi
    else
      pending=$((pending + 1))
    fi
  done

  for repo in "${SUNSET_REPOS[@]}"; do
    [[ "$(get_repo_visibility "$SOURCE_ORG" "$repo")" == "private" ]] && sunset=$((sunset + 1))
  done

  echo "  Fully migrated:     $done / ${#MIGRATION_MAP[@]}"
  echo "  Empty (need push):  $empty"
  echo "  Not started:        $pending"
  echo "  Sunset (private):   $sunset / ${#SUNSET_REPOS[@]}"
  echo ""
}

cmd_plan_projects() {
  echo "=============================================="
  echo "  Project Migration Plan: ${SOURCE_ORG} â†’ ${TARGET_ORG}"
  echo "=============================================="
  echo ""

  echo "ðŸ“‹ PROJECTS TO MIGRATE:"
  echo "-----------------------"
  local migrate_count=0

  for mapping in "${PROJECT_MAP[@]}"; do
    local source="${mapping%%:*}"
    local target="${mapping#*:}"
    local status=""

    local source_num
    source_num=$(gh project list --owner "$SOURCE_ORG" --format json \
      | jq -r --arg name "$source" '.projects[] | select(.title == $name) | .number' 2>/dev/null)

    local target_num
    target_num=$(gh project list --owner "$TARGET_ORG" --format json \
      | jq -r --arg name "$target" '.projects[] | select(.title == $name) | .number' 2>/dev/null)

    if [[ -n "$target_num" ]]; then
      status="${GREEN}(done - #${target_num})${NC}"
    elif [[ -z "$source_num" ]]; then
      status="${RED}(source not found)${NC}"
    else
      status="${BLUE}(ready - #${source_num})${NC}"
      migrate_count=$((migrate_count + 1))
    fi

    printf "  %-30s â†’ %-20s %b\n" "$source" "$target" "$status"
  done
  echo ""
  echo "  To migrate: $migrate_count"
  echo ""
}

cmd_migrate_projects() {
  local dry_run="${1:-}"
  [[ "$dry_run" == "--dry-run" ]] && log_info "DRY RUN" && echo ""

  echo "=============================================="
  echo "  GitHub Projects Migration"
  echo "=============================================="
  echo ""

  local success=0 skip=0 fail=0

  for mapping in "${PROJECT_MAP[@]}"; do
    local source="${mapping%%:*}"
    local target="${mapping#*:}"

    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "  $source â†’ $target"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    local source_num
    source_num=$(gh project list --owner "$SOURCE_ORG" --format json \
      | jq -r --arg name "$source" '.projects[] | select(.title == $name) | .number' 2>/dev/null)

    if [[ -z "$source_num" ]]; then
      log_error "Source not found"
      fail=$((fail + 1))
      continue
    fi

    local target_num
    target_num=$(gh project list --owner "$TARGET_ORG" --format json \
      | jq -r --arg name "$target" '.projects[] | select(.title == $name) | .number' 2>/dev/null)

    if [[ -n "$target_num" ]]; then
      log_success "Already exists (#${target_num}) - skip"
      skip=$((skip + 1))
      continue
    fi

    if [[ "$dry_run" == "--dry-run" ]]; then
      log_info "[DRY] Would copy project #${source_num}"
      success=$((success + 1))
      continue
    fi

    log_info "Copying project #${source_num}"
    if gh project copy "$source_num" \
      --source-owner "$SOURCE_ORG" \
      --target-owner "$TARGET_ORG" \
      --title "$target" \
      --drafts >/dev/null 2>&1; then
      log_success "Copied"
      success=$((success + 1))
    else
      log_error "Failed to copy"
      fail=$((fail + 1))
    fi
    echo ""
  done

  echo "=============================================="
  echo "  Summary"
  echo "=============================================="
  echo -e "  ${GREEN}Success:${NC} $success"
  echo -e "  ${YELLOW}Skipped:${NC} $skip"
  echo -e "  ${RED}Failed:${NC}  $fail"
  echo ""
}

cmd_migrate_all() {
  local dry_run="${1:-}"

  echo "=============================================="
  echo "  Full Migration: ${SOURCE_ORG} â†’ ${TARGET_ORG}"
  echo "=============================================="
  echo ""

  echo "Step 1/3: Migrate code (branches, tags)"
  echo "----------------------------------------"
  cmd_migrate "$dry_run"

  echo ""
  echo "Step 2/3: Migrate issues"
  echo "------------------------"
  cmd_migrate_issues "$dry_run"

  echo ""
  echo "Step 3/3: Migrate PRs"
  echo "---------------------"
  cmd_migrate_prs "$dry_run"

  echo ""
  echo "=============================================="
  echo "  Migration Complete"
  echo "=============================================="
  echo ""
  echo "Next steps:"
  echo "  1. Verify repos: ./scripts/migrate-to-jbcom status"
  echo "  2. Make source repos private: ./scripts/migrate-to-jbcom privatize-migrated"
  echo "  3. Make sunset repos private: ./scripts/migrate-to-jbcom privatize"
  echo ""
}

show_help() {
  cat << EOF
Usage: $(basename "$0") <command> [options]

Repository Commands:
  plan                      Show migration plan
  status                    Show migration status
  migrate [--dry-run]       Migrate code (branches, tags)
  migrate-issues [--dry-run] Migrate open issues
  migrate-prs [--dry-run]   Migrate open PRs
  migrate-all [--dry-run]   Full migration (code + issues + PRs)

Project Commands:
  plan-projects             Show GitHub Projects migration plan
  migrate-projects [--dry-run]  Migrate GitHub Projects

Cleanup Commands:
  privatize [--dry-run]     Make sunset repos private
  privatize-migrated        Make migrated source repos private

All commands are idempotent - safe to run multiple times.

Source: ${SOURCE_ORG}
Target: ${TARGET_ORG}
EOF
}

main() {
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    plan) cmd_plan ;;
    status) cmd_status ;;
    migrate) cmd_migrate "$@" ;;
    migrate-issues) cmd_migrate_issues "$@" ;;
    migrate-prs) cmd_migrate_prs "$@" ;;
    migrate-all) cmd_migrate_all "$@" ;;
    plan-projects) cmd_plan_projects ;;
    migrate-projects) cmd_migrate_projects "$@" ;;
    privatize) cmd_privatize "$@" ;;
    privatize-migrated) cmd_privatize_migrated "$@" ;;
    -h|--help|help|"") show_help ;;
    *) log_error "Unknown: $cmd"; show_help; exit 1 ;;
  esac
}

main "$@"
