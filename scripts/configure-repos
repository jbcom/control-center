#!/usr/bin/env bash
# =============================================================================
# configure-repos - Configure GitHub repositories using gh CLI
# =============================================================================
# Replaces Terraform repository configuration with gh CLI operations.
# Uses repo-config.json as the source of truth.
#
# Usage:
#   ./scripts/configure-repos [options] [repo...]
#
# Options:
#   --dry-run       Show what would be configured without making changes
#   --all           Configure all repos (default if no repo specified)
#   --diff          Show differences between current and desired state
#
# Examples:
#   ./scripts/configure-repos                    # Configure all repos
#   ./scripts/configure-repos strata             # Configure specific repo
#   ./scripts/configure-repos --diff --all       # Show drift for all repos
# =============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="${SCRIPT_DIR}/.."
CONFIG_FILE="${REPO_ROOT}/repo-config.json"
GITHUB_ORG="${GITHUB_ORG:-jbdevprimary}"

# Options
DRY_RUN=false
SHOW_DIFF=false

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info()  { echo -e "${BLUE}[INFO]${NC} $*"; }
log_ok()    { echo -e "${GREEN}[OK]${NC} $*"; }
log_warn()  { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
log_diff()  { echo -e "${CYAN}[DIFF]${NC} $*"; }

# =============================================================================
# Functions
# =============================================================================

get_all_repos() {
  jq -r '.ecosystems | to_entries[] | .value.repos[]' "$CONFIG_FILE"
}

get_repo_override() {
  local repo="$1"
  local field="$2"
  jq -r --arg repo "$repo" --arg field "$field" \
    '.overrides[$repo][$field] // empty' "$CONFIG_FILE"
}

get_merge_setting() {
  local field="$1"
  jq -r ".defaults.merge_settings.${field}" "$CONFIG_FILE"
}

get_feature() {
  local field="$1"
  jq -r ".defaults.features.${field}" "$CONFIG_FILE"
}

get_current_config() {
  local repo="$1"
  gh api "repos/${GITHUB_ORG}/${repo}" 2>/dev/null || echo "{}"
}

configure_repo() {
  local repo="$1"
  local full_repo="${GITHUB_ORG}/${repo}"
  
  log_info "Configuring: $repo"
  
  # Get current state
  local current
  current=$(get_current_config "$repo")
  
  if [[ "$current" == "{}" ]]; then
    log_warn "  Could not fetch current config"
    return 1
  fi
  
  # SAFETY: Never change these fields
  # - visibility (private/public) - NEVER CHANGE
  # - description - only if explicitly set in overrides
  # - name - NEVER CHANGE
  
  local current_visibility
  current_visibility=$(echo "$current" | jq -r '.visibility // "public"')
  log_info "  Visibility: $current_visibility (preserved)"
  
  # Only include description if explicitly overridden
  local description_override
  description_override=$(get_repo_override "$repo" "description")
  
  # Build the update payload - ONLY merge/branch settings and features
  # NEVER: visibility, description, name
  local payload
  payload=$(jq -n \
    --argjson has_issues "$(get_feature 'has_issues')" \
    --argjson has_projects "$(get_feature 'has_projects')" \
    --argjson has_wiki "$(get_feature 'has_wiki')" \
    --argjson allow_squash_merge "$(get_merge_setting 'allow_squash_merge')" \
    --argjson allow_merge_commit "$(get_merge_setting 'allow_merge_commit')" \
    --argjson allow_rebase_merge "$(get_merge_setting 'allow_rebase_merge')" \
    --argjson delete_branch_on_merge "$(get_merge_setting 'delete_branch_on_merge')" \
    --arg squash_title "$(get_merge_setting 'squash_merge_commit_title')" \
    --arg squash_message "$(get_merge_setting 'squash_merge_commit_message')" \
    '{
      has_issues: $has_issues,
      has_projects: $has_projects,
      has_wiki: $has_wiki,
      allow_squash_merge: $allow_squash_merge,
      allow_merge_commit: $allow_merge_commit,
      allow_rebase_merge: $allow_rebase_merge,
      delete_branch_on_merge: $delete_branch_on_merge,
      squash_merge_commit_title: $squash_title,
      squash_merge_commit_message: $squash_message
    }')
  
  # Show diff if requested
  if [[ "$SHOW_DIFF" == "true" ]]; then
    echo "  Current vs Desired (safe fields only):"
    
    # Compare key fields - only the ones we actually manage
    local fields=("has_wiki" "allow_squash_merge" "allow_merge_commit" "allow_rebase_merge" "delete_branch_on_merge")
    local has_diff=false
    
    for field in "${fields[@]}"; do
      local current_val desired_val
      current_val=$(echo "$current" | jq -r ".${field}")
      desired_val=$(echo "$payload" | jq -r ".${field}")
      
      if [[ "$current_val" != "$desired_val" ]]; then
        log_diff "    $field: $current_val → $desired_val"
        has_diff=true
      fi
    done
    
    # Show protected fields
    echo "  Protected (never changed):"
    echo "    visibility: $(echo "$current" | jq -r '.visibility')"
    echo "    description: $(echo "$current" | jq -r '.description // "(none)"' | head -c 50)..."
    
    if [[ "$has_diff" != "true" ]]; then
      log_ok "  No differences in managed fields"
    fi
    
    return 0
  fi
  
  # Apply configuration
  if [[ "$DRY_RUN" == "true" ]]; then
    log_info "  [DRY RUN] Would apply (safe fields only):"
    echo "$payload" | jq -c '.'
    log_info "  [DRY RUN] Protected fields preserved: visibility, description"
  else
    if gh api "repos/${full_repo}" -X PATCH --input - <<< "$payload" >/dev/null 2>&1; then
      log_ok "  Configuration applied (visibility/description preserved)"
    else
      log_error "  Failed to apply configuration"
      return 1
    fi
    
    # Configure security settings (only for public repos)
    if [[ "$current_visibility" == "public" ]]; then
      configure_security "$repo"
    fi
  fi
  
  # Sync rulesets (works in both dry-run and apply modes)
  sync_rulesets "$repo"
}

configure_security() {
  local repo="$1"
  local full_repo="${GITHUB_ORG}/${repo}"
  
  # Enable Dependabot security updates
  gh api "repos/${full_repo}/automated-security-fixes" -X PUT >/dev/null 2>&1 || true
}

get_existing_rulesets() {
  local repo="$1"
  gh api "repos/${GITHUB_ORG}/${repo}/rulesets" --jq '.[].name' 2>/dev/null || echo ""
}

sync_ruleset() {
  local repo="$1"
  local ruleset_key="$2"
  local full_repo="${GITHUB_ORG}/${repo}"
  
  # Get ruleset config from JSON
  local ruleset_config
  ruleset_config=$(jq -c ".rulesets.${ruleset_key}" "$CONFIG_FILE")
  
  local ruleset_name
  ruleset_name=$(echo "$ruleset_config" | jq -r '.name')
  
  # Check if ruleset already exists
  local existing_id
  existing_id=$(gh api "repos/${full_repo}/rulesets" --jq ".[] | select(.name == \"${ruleset_name}\") | .id" 2>/dev/null || echo "")
  
  # Build the API payload
  local payload
  payload=$(echo "$ruleset_config" | jq '{
    name: .name,
    target: .target,
    enforcement: .enforcement,
    conditions: .conditions,
    bypass_actors: .bypass_actors,
    rules: .rules
  }')
  
  if [[ -n "$existing_id" ]]; then
    # Update existing ruleset
    if [[ "$DRY_RUN" == "true" ]]; then
      log_info "    [DRY RUN] Would update ruleset: $ruleset_name (id: $existing_id)"
    else
      if gh api "repos/${full_repo}/rulesets/${existing_id}" -X PUT --input - <<< "$payload" >/dev/null 2>&1; then
        log_ok "    Updated ruleset: $ruleset_name"
      else
        log_warn "    Failed to update ruleset: $ruleset_name"
      fi
    fi
  else
    # Create new ruleset
    if [[ "$DRY_RUN" == "true" ]]; then
      log_info "    [DRY RUN] Would create ruleset: $ruleset_name"
    else
      if gh api "repos/${full_repo}/rulesets" -X POST --input - <<< "$payload" >/dev/null 2>&1; then
        log_ok "    Created ruleset: $ruleset_name"
      else
        log_warn "    Failed to create ruleset: $ruleset_name (may need higher permissions)"
      fi
    fi
  fi
}

sync_rulesets() {
  local repo="$1"
  
  log_info "  Syncing rulesets..."
  
  # Sync each defined ruleset
  for ruleset_key in $(jq -r '.rulesets | keys[] | select(. != "_comment")' "$CONFIG_FILE"); do
    sync_ruleset "$repo" "$ruleset_key"
  done
}

show_help() {
  echo ""
  echo "Usage: configure-repos [options] [repo...]"
  echo ""
  echo "Configure GitHub repositories using gh CLI."
  echo "Uses repo-config.json as the source of truth."
  echo ""
  echo "Options:"
  echo "  --dry-run     Show what would be configured without making changes"
  echo "  --diff        Show differences between current and desired state"
  echo "  --all         Configure all repos (default if no repo specified)"
  echo "  --help        Show this help"
  echo ""
  echo "Examples:"
  echo "  ./scripts/configure-repos                    # Configure all repos"
  echo "  ./scripts/configure-repos strata             # Configure specific repo"
  echo "  ./scripts/configure-repos --diff --all       # Show config drift"
  echo ""
}

# =============================================================================
# Main
# =============================================================================

main() {
  local repos=()
  local configure_all=false
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --diff)
        SHOW_DIFF=true
        shift
        ;;
      --all)
        configure_all=true
        shift
        ;;
      --help|-h)
        show_help
        exit 0
        ;;
      -*)
        log_error "Unknown option: $1"
        show_help
        exit 1
        ;;
      *)
        repos+=("$1")
        shift
        ;;
    esac
  done
  
  # If no repos specified, configure all
  if [[ ${#repos[@]} -eq 0 ]] || [[ "$configure_all" == "true" ]]; then
    mapfile -t repos < <(get_all_repos)
  fi
  
  echo ""
  echo "═══════════════════════════════════════════════════════════════════════════════"
  echo "  REPOSITORY CONFIGURATION (gh CLI)"
  echo "═══════════════════════════════════════════════════════════════════════════════"
  echo ""
  
  if [[ "$DRY_RUN" == "true" ]]; then
    log_warn "DRY RUN - no changes will be made"
    echo ""
  fi
  
  if [[ "$SHOW_DIFF" == "true" ]]; then
    log_info "Showing configuration drift..."
    echo ""
  fi
  
  local count=0
  local errors=0
  
  for repo in "${repos[@]}"; do
    if configure_repo "$repo"; then
      ((count++))
    else
      ((errors++))
    fi
  done
  
  echo ""
  log_ok "Processed $count repositories"
  if [[ $errors -gt 0 ]]; then
    log_warn "$errors repositories had errors"
  fi
}

main "$@"
