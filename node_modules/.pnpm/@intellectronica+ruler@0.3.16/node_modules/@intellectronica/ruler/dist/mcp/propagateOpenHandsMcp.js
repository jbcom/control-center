"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.propagateMcpToOpenHands = propagateMcpToOpenHands;
const fs = __importStar(require("fs/promises"));
const toml_1 = require("@iarna/toml");
const FileSystemUtils_1 = require("../core/FileSystemUtils");
const path = __importStar(require("path"));
function isRulerMcpServer(value) {
    const server = value;
    return (server &&
        (typeof server.command === 'string' || typeof server.url === 'string'));
}
function classifyRemoteServer(url) {
    // Heuristic: URLs containing /sse path segments are classified as SSE
    return /\/sse(\/|$)/i.test(url) ? 'sse' : 'shttp';
}
function extractApiKey(headers) {
    if (!headers)
        return null;
    const authHeader = headers.Authorization || headers.authorization;
    if (!authHeader)
        return null;
    // Extract Bearer token if that's the only header, or if only Authorization + standard content headers
    const headerCount = Object.keys(headers).length;
    const hasOnlyAuthHeader = headerCount === 1;
    const hasOnlyStandardHeaders = headerCount <= 2 &&
        (headers['Content-Type'] ||
            headers['content-type'] ||
            headers['Accept'] ||
            headers['accept']);
    if ((hasOnlyAuthHeader || hasOnlyStandardHeaders) &&
        authHeader.startsWith('Bearer ')) {
        return authHeader.substring('Bearer '.length);
    }
    return null;
}
function createRemoteServerEntry(url, headers) {
    const apiKey = extractApiKey(headers);
    if (apiKey) {
        return { url, api_key: apiKey };
    }
    return url;
}
function normalizeRemoteServerArray(entries) {
    // TOML doesn't support mixed types in arrays, so we need to be consistent
    // If any entry is an object, convert all simple URLs to objects
    const hasObjectEntries = entries.some((entry) => typeof entry === 'object');
    if (hasObjectEntries) {
        return entries.map((entry) => {
            if (typeof entry === 'string') {
                return { url: entry };
            }
            return entry;
        });
    }
    // All entries are strings, keep as is
    return entries;
}
async function propagateMcpToOpenHands(rulerMcpData, openHandsConfigPath, backup = true) {
    const rulerMcp = rulerMcpData || {};
    // Always use the legacy Ruler MCP config format as input (top-level "mcpServers" key)
    const rulerServers = rulerMcp.mcpServers || {};
    // Return early if no servers to process
    if (!rulerServers ||
        typeof rulerServers !== 'object' ||
        Object.keys(rulerServers).length === 0) {
        return;
    }
    let config = {};
    try {
        const tomlContent = await fs.readFile(openHandsConfigPath, 'utf8');
        config = (0, toml_1.parse)(tomlContent);
    }
    catch {
        // File doesn't exist, we'll create it.
    }
    if (!config.mcp) {
        config.mcp = {};
    }
    if (!config.mcp.stdio_servers) {
        config.mcp.stdio_servers = [];
    }
    if (!config.mcp.sse_servers) {
        config.mcp.sse_servers = [];
    }
    if (!config.mcp.shttp_servers) {
        config.mcp.shttp_servers = [];
    }
    // Build maps for merging existing servers
    const existingStdioServers = new Map(config.mcp.stdio_servers.map((s) => [s.name, s]));
    const existingSseServers = new Map();
    config.mcp.sse_servers.forEach((entry) => {
        const url = typeof entry === 'string' ? entry : entry.url;
        existingSseServers.set(url, entry);
    });
    const existingShttpServers = new Map();
    config.mcp.shttp_servers.forEach((entry) => {
        const url = typeof entry === 'string' ? entry : entry.url;
        existingShttpServers.set(url, entry);
    });
    for (const [name, serverDef] of Object.entries(rulerServers)) {
        if (isRulerMcpServer(serverDef)) {
            if (serverDef.command) {
                // Stdio server
                const { command, args, env } = serverDef;
                const newServer = { name, command };
                if (args)
                    newServer.args = args;
                if (env)
                    newServer.env = env;
                existingStdioServers.set(name, newServer);
            }
            else if (serverDef.url) {
                // Remote server
                const classification = classifyRemoteServer(serverDef.url);
                const entry = createRemoteServerEntry(serverDef.url, serverDef.headers);
                if (classification === 'sse') {
                    existingSseServers.set(serverDef.url, entry);
                }
                else {
                    existingShttpServers.set(serverDef.url, entry);
                }
            }
        }
    }
    // Convert maps back to arrays and normalize for TOML compatibility
    config.mcp.stdio_servers = Array.from(existingStdioServers.values());
    config.mcp.sse_servers = normalizeRemoteServerArray(Array.from(existingSseServers.values()));
    config.mcp.shttp_servers = normalizeRemoteServerArray(Array.from(existingShttpServers.values()));
    await (0, FileSystemUtils_1.ensureDirExists)(path.dirname(openHandsConfigPath));
    if (backup) {
        const { backupFile } = await Promise.resolve().then(() => __importStar(require('../core/FileSystemUtils')));
        await backupFile(openHandsConfigPath);
    }
    await fs.writeFile(openHandsConfigPath, (0, toml_1.stringify)(config));
}
