"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpCursorApiClient = void 0;
const domain_1 = require("../domain");
class HttpCursorApiClient {
    constructor(apiKey) {
        this.baseUrl = "https://api.cursor.com/v0";
        if (!apiKey) {
            throw new Error("API key is required");
        }
        this.apiKey = apiKey;
    }
    async makeRequest(endpoint, method = "GET", body) {
        const url = `${this.baseUrl}${endpoint}`;
        const headers = {
            "Authorization": `Bearer ${this.apiKey}`,
            "Content-Type": "application/json",
        };
        const response = await fetch(url, {
            method,
            headers,
            body: body ? JSON.stringify(body) : undefined,
        });
        if (!response.ok) {
            const errorText = await response.text();
            let parsed = undefined;
            try {
                parsed = JSON.parse(errorText);
            }
            catch {
            }
            const details = parsed ?? errorText;
            switch (response.status) {
                case 401:
                    throw new domain_1.MCPErrorImpl(domain_1.MCP_ERROR_CODES.AUTHENTICATION_FAILED, "Invalid API key or authentication failed. Ensure CURSOR_API_KEY is set and valid.", { status: response.status, details, endpoint });
                case 404: {
                    let message = "Resource not found.";
                    if (endpoint === "/models" || endpoint.includes("/models")) {
                        message = "Models endpoint not available or authentication failed. Verify CURSOR_API_KEY and account access.";
                    }
                    else if (endpoint.startsWith("/agents")) {
                        message = "Requested resource not found. If launching an agent, verify repository URL format (https://github.com/owner/repo) and that the Cursor GitHub App is installed on the repository.";
                    }
                    throw new domain_1.MCPErrorImpl(domain_1.MCP_ERROR_CODES.RESOURCE_NOT_FOUND, message, { status: response.status, details, endpoint });
                }
                case 429:
                    throw new domain_1.MCPErrorImpl(domain_1.MCP_ERROR_CODES.RATE_LIMITED, "Rate limit exceeded", { status: response.status, details, endpoint });
                case 503:
                    throw new domain_1.MCPErrorImpl(domain_1.MCP_ERROR_CODES.SERVICE_UNAVAILABLE, "Cursor API service unavailable", { status: response.status, details, endpoint });
                case 408:
                    throw new domain_1.MCPErrorImpl(domain_1.MCP_ERROR_CODES.TIMEOUT, "Request timeout", { status: response.status, details, endpoint });
                default:
                    throw new domain_1.MCPErrorImpl(domain_1.MCP_ERROR_CODES.INTERNAL_ERROR, `Cursor API error: ${response.status} ${response.statusText}`, { status: response.status, details, endpoint });
            }
        }
        return response.json();
    }
    async launchAgent(input) {
        return this.makeRequest("/agents", "POST", input);
    }
    async listAgents() {
        return this.makeRequest("/agents");
    }
    async listModels() {
        return this.makeRequest("/models");
    }
    async addFollowup(agentId, input) {
        return this.makeRequest(`/agents/${agentId}/followup`, "POST", input);
    }
    async getAgentConversation(agentId) {
        return this.makeRequest(`/agents/${agentId}/conversation`);
    }
    async getAgentStatus(agentId) {
        return this.makeRequest(`/agents/${agentId}`);
    }
    async listRepositories() {
        try {
            return await this.makeRequest("/repositories");
        }
        catch (error) {
            if (error?.code === "RATE_LIMITED" || error?.message?.includes("rate limit")) {
                return { error: "Rate limit exceeded. Please try again later." };
            }
            if (error?.message?.includes("timeout") || error?.message?.includes("unavailable")) {
                return { error: "Repository information is temporarily unavailable. Please try again later." };
            }
            throw error;
        }
    }
}
exports.HttpCursorApiClient = HttpCursorApiClient;
//# sourceMappingURL=cursorApiClient.js.map