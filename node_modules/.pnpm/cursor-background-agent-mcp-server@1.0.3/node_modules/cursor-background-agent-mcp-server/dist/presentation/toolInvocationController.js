"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setToolExecutor = setToolExecutor;
exports.invokeTool = invokeTool;
const manifest_1 = require("../domain/manifest");
const ajv_1 = __importDefault(require("ajv"));
const domain_1 = require("../domain");
const ajv = new ajv_1.default();
let toolExecutor;
function setToolExecutor(executor) {
    toolExecutor = executor;
}
async function invokeTool(toolName, input) {
    if (!toolExecutor) {
        throw new domain_1.MCPErrorImpl(domain_1.MCP_ERROR_CODES.SERVICE_UNAVAILABLE, "Tool executor not initialized");
    }
    const tool = manifest_1.manifest.tools.find(t => t.name === toolName);
    if (!tool) {
        throw new domain_1.MCPErrorImpl(domain_1.MCP_ERROR_CODES.TOOL_NOT_FOUND, `Tool '${toolName}' not found`);
    }
    const validate = ajv.compile(tool.inputSchema);
    const valid = validate(input);
    if (!valid) {
        throw new domain_1.MCPErrorImpl(domain_1.MCP_ERROR_CODES.INVALID_INPUT, "Input validation failed", validate.errors);
    }
    return await toolExecutor.execute(toolName, input);
}
//# sourceMappingURL=toolInvocationController.js.map