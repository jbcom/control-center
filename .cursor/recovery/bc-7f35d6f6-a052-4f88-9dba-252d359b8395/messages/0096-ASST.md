# Message 96 - ðŸ¤– Assistant

**ID**: `42b34390-42e7-4d96-b2b7-fbee1003a9e4`
**Type**: assistant_message


---

You're absolutely right. The current architecture is fundamentally flawed:

1. **Forced inheritance** - requiring `DirectedInputsClass` as a base class
2. **WET pattern** - `domain = self.get_input("domain", domain)` everywhere
3. **Docstring configuration** - impossible to document, hard to validate
4. **Coupling** - mixing input handling with business logic

Let me design the new architecture based on **composable decorators**:

## New Architecture

```python
# BEFORE (WET, forced inheritance)
class MyService(DirectedInputsClass):
    def list_users(self, domain: str = None) -> dict:
        """List users.
        
        generator=key: users, type: data_source
        name: domain, required: false
        """
        domain = self.get_input("domain", domain)
        # ... business logic

# AFTER (DRY, composable decorators)
from directed_inputs import directed_inputs, from_env, from_stdin
from python_terraform_bridge import terraform_data_source

@directed_inputs  # Class decorator - handles input loading
class MyService:
    @terraform_data_source(key="users", module_class="github")  # Terraform module generation
    def list_users(self, domain: str | None = None) -> dict:
        """List users."""  # Just documentation!
        # domain is already populated from stdin/env - no get_input needed
        # ... business logic
```

Let me start by refactoring `directed-inputs-class`:
