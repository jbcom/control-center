[
  {
    "id": "2fde379f-c37a-467f-b926-0ec49d32750e",
    "type": "user_message",
    "text": "Also I wanted to share the contents of a medium article. Altough we use pycalver and not semver it is VERY adaptable to OUR flow and we BADLY need structural alignment:\n\n\nOpen in app\nSidebar menu\n\n\nReleasing a Monorepo using uv Workspace and Python Semantic Release\n\nAsaf Shakarzy\n\nFollowing\n7 min read\n¬∑\nMar 16, 2025\n\n\n\nManaging multiple Python packages separately can be a hassle ‚Äî different lifecycles, dependency mismatches, and endless coordination. A uv workspace, inspired by Rust‚Äôs Cargo workspaces, simplifies this by managing all packages under one monorepo, ensuring consistent versioning and reducing overhead.\n\nAt Flux0, we leverage this setup to streamline our AI-powered assistant orchestration framework, automating versioning and releases across multiple packages with python-semantic-release (PSR). This combination ensures a smooth publishing workflow, making updates effortless and consistent.\n\nBut even with a monorepo, releases can get complicated. Each package within the workspace requires its own changelog, Git tag, build artifacts, and GitHub release. The root project itself may also have its own versioning and release cycle. Keeping everything in sync manually? Painful.\n\nThis is where python-semantic-release (PSR) comes in. It automates versioning, changelogs, and publishing based on commit messages. In this guide, we‚Äôll walk through integrating PSR into your uv workspace for seamless, structured releases ‚Äî just like we do in Flux0.\n\nFor a complete repo of this blog see https://github.com/asaf/uvws\n\nSetting Up the uv Workspace\nWe‚Äôll start by creating a uv workspace with a root project and two packages (core and svc1). This setup allows us to manage multiple services in a single repository while keeping each package independent. Since these packages may depend on each other, managing versions correctly is crucial to avoid compatibility issues.\n\nInitializing the Workspace\nmkdir uvws && cd uvws\nuv init --package  # Initialize the root project\n\n# Test the root project\nuv run uvws uvws  # Expected output: Hello from uvws!\n\n# Initialize the core package\nuv init packages/core --package --name uvws-core\n# run the core script (see pyproject.toml project.scripts])\nuv run --package uvws-core uvws-core  # Expected output: Hello from uvws-core!\n# can run via python (this works because uv creates pth file per package)\nsource ./.venv/bin/activate\npython -c \"from uvws_core import main; main()\"\nAdding Functionality to core\necho -e '\\n__version__ = \"0.0.0\"\\n\\ndef hi() -> str:\\n    return \"hi from core\"' >> ./packages/core/src/uvws_core/__init__.py\n\n# Run the method\nuv run --package uvws-core python -c \"import uvws_core; print(uvws_core.hi())\"\nCreating and Linking svc1\nuv init packages/svc1 --package --name uvws-svc1\nuv run --package uvws-svc1 uvws-svc1  # Expected output: Hello from uvws-svc1!\n\n# Make core a dependency of svc1\nuv add --package uvws-svc1 ./packages/core\n\n# Verify dependencies\ncat ./packages/svc1/pyproject.toml\ncore is now listed in dependencies, and uv ensures that workspace packages are properly linked (check svc1's pyproject.toml)\n\nUsing core in svc1\necho -e 'from uvws_core import hi\\n\\n__version__ = \"0.0.0\"\\n\\n\\ndef main() -> None:\\n    print(\"svc1 say: \", hi())' > packages/svc1/src/uvws_svc1/__init__.py\n\n# Test the updated svc1 (by running the uvws-svc1 script)\nuv run --package uvws_svc1 uvws-svc1  # Expected output: hi from core\nAny changes in core are now automatically reflected in svc1, ensuring smooth dependency updates within the workspace.\n\nEnsuring Build works\nLet‚Äôs verify that the build process runs correctly:\n\nuv build --all-packages  # Builds uvws, core, and svc1\ntar -tzf ./dist/uvws_svc1-0.1.0.tar.gz # inspect tgz package\nunzip -l ./dist/uvws_svc1-0.1.0-py3-none-any.whl # inspect whl package\n# inspect that svc1 package depends on uvws-core package\nunzip -p ./dist/uvws_svc1-0.1.0-py3-none-any.whl 'uvws_svc1-0.1.0.dist-info/METADATA' | grep '^Requires-Dist'\nrm -rf ./dist\nWith our workspace set up, it‚Äôs time to automate releases using python-semantic-release.\n\nAutomating Releases with python-semantic-release\nNow that our uv workspace is in place, we need to automate releases for core, svc1, and the root project uvws. Each package requires independent versioning, changelogs, and GitHub releases, all of which can be efficiently managed using python-semantic-release.\n\nWe‚Äôll configure PSR to:\n\nDetect changes in each package based on file paths and commit messages.\nAutomatically bump versions using Conventional Commits.\nTag and update relevant files with the new version.\nGenerate changelogs and GitHub releases.\nConventional Commit Structure\nConventional Commits follows:\n\n<type>[optional scope]: <description>\nFor monorepos, it‚Äôs recommended to scope commits to specific packages:\n\n<type>[<pkg>-optional scope]: <description>\nThis improves readability and helps filter changes per package.\n\nExample Commit Messages\nfeat(core): add new feature ‚Üí Only affects core\nfix(core-readme): update documentation ‚Üí Still relevant to core\nThe monorepo parser primarily filters by commited files paths (e.g., <root>/packages/core). It can also use commit scopes with scope_prefix\n\nInstalling Dependencies\nuv add python-semantic-release --dev\nDownloading the Monorepo Parser\nNote: This is a temporary solution until the monorepo parser is officially released as part of PSR.\n\nmkdir -p ./scripts/psr/custom_parser\ncurl https://raw.githubusercontent.com/asaf/uvws/refs/heads/main/scripts/psr/custom_parser/monorepo_parser.py -o ./scripts/psr/custom_parser/monorepo_parser.py\nConfiguring PSR for core\nSince we‚Äôre working in a monorepo, we need PSR to only consider commits relevant to core.\n\nReleases in main will create a release such 0.1.0 while pushes to beta branch will create a release such 0.1.0-beta.1\ncat <<'EOF' >> ./packages/core/pyproject.toml\n\n[tool.semantic_release]\nbuild_command = \"pip install uv && uv build\"\ncommit_parser = \"../../scripts/psr/custom_parser/monorepo_parser.py:ConventionalCommitMonorepoParser\"\ncommit_message = \"\"\"\nchore(core-release): Release `core@{version}` [skip ci]\nAutomatically generated by python-semantic-release\n\"\"\"\nallow_zero_version = true\ntag_format = \"core-{version}\"\nversion_toml = [\"pyproject.toml:project.version\"]\nversion_variables = [\"src/uvws_core/__init__.py:__version__\"]\n\n[tool.semantic_release.branches.main]\nmatch = \"main\"\nprerelease = false\n\n[tool.semantic_release.branches.beta]\nmatch = \"beta\"\nprerelease = true\nprerelease_token = \"beta\"\n\n[tool.semantic_release.publish]\ndist_glob_patterns = [\"../../dist/uvws_core-*\"]\n\nEOF\nSince PSR syncs with remote repositories, we need to set up our Git repo before running the version command.\n\ngit init\ngit add .\ngit commit -m 'feat: initial commit'\ngit remote add origin https://github.com/<user>/uvws\ngit branch -M main\ngit push origin main\nWith this setup, python-semantic-release is now ready to handle versioning and releases efficiently!\n\nReleasing core\nLets make a minor change in coreand commit it\n\n# change \"hi from core\" -> \"hi from core!\"\nsed -i '' 's/return \"hi from core\"/return \"hi from core!\"/' packages/core/src/uvws_core/__init__.py\ngit add packages/core/src/uvws_core/__init__.py\ngit commit -m 'fix(core): a minor change in __init__.py'\nTo release core package:\n\ncd packages/core\n# next version is 0.1.0\nsemantic-release --noop version --print\n# create the release\nsemantic-release version\nSince this is the first release with a single commit prefixed withfeat, the initial version will be 0.1.0-beta.1, and a CHANGELOG.md will be generated which includes the Initial Release.\n\nPSR will include in core‚Äôs CHANGELOG.md only the commits containing modifications of files within the core package.\n\nConfiguring PSR for svc1\nSame as with core, define PSR configuration in pyproject.toml that matches svc1:\n\n# NOTE: change dir to project's root folder\ncat <<'EOF' >> ./packages/svc1/pyproject.toml\n[tool.semantic_release]\nbuild_command = \"pip install uv && uv build\"\ncommit_parser = \"../../scripts/psr/custom_parser/monorepo_parser.py:ConventionalCommitMonorepoParser\"\ncommit_message = \"\"\"\\\nchore(svc1-release): Release `svc1@{version}` [skip ci]\nAutomatically generated by python-semantic-release\n\"\"\"\n\nallow_zero_version = true\ntag_format = \"svc1-{version}\"\nversion_toml = [\"pyproject.toml:project.version\"]\nversion_variables = [\"src/uvws_svc1/__init__.py:__version__\"]\n\n[tool.semantic_release.branches.main]\nmatch = \"main\"\nprerelease = false\n\n[tool.semantic_release.branches.beta]\nmatch = \"beta\"\nprerelease = true\nprerelease_token = \"beta\"\n\n[tool.semantic_release.publish]\ndist_glob_patterns = [\"../../dist/uvws_svc1-*\"]\nEOF\n\ngit add packages/svc1/pyproject.toml\ngit commit -m 'chore: configure PSR in svc1'\nReleasing svc1\ncd packages/svc1\n# next version is 0.1.0\nsemantic-release --noop version --print\n# create the release\nsemantic-release version\nConfigure PSR for Root package (uvws)\nAdd a __version__ variable, making it easier to get the version of the package in runtime.\n\necho \"\\n\\n__version__= \\\"0.0.0\\\"\"  >> ./src/uvws/__init__.py\n# NOTE: change dir to project's root folder\ncat <<'EOF' >> ./pyproject.toml\n\n[tool.semantic_release]\nbuild_command = \"pip install uv && uv build\"\ncommit_parser = \"./scripts/psr/custom_parser/monorepo_parser.py:ConventionalCommitMonorepoParser\"\ncommit_message = \"\"\"\\\nchore(uvws-release): Release `uvws@{version}` [skip ci]\nAutomatically generated by python-semantic-release\n\"\"\"\nallow_zero_version = true\ntag_format = \"uvws-{version}\"\nversion_toml = [\"pyproject.toml:project.version\"]\nversion_variables = [\"src/uvws/__init__.py:__version__\"]\n\n[tool.semantic_release.commit_parser_options]\npath_filters=[\".\", \"!packages/core/*\", \"!packages/svc1/*\"]\n\n[tool.semantic_release.branches.main]\nmatch = \"main\"\nprerelease = false\n\n[tool.semantic_release.branches.beta]\nmatch = \"beta\"\nprerelease = true\nprerelease_token = \"beta\"\n\n[tool.semantic_release.publish]\ndist_glob_patterns = [\"./dist/uvws-*\"]\n\nEOF\n\ngit add pyproject.toml ./src/uvws/__init__.py\ngit commit -m 'chore: configure PSR for root package'\nReleasing root package\n# next version is 0.1.0\nsemantic-release --noop version --print\n# create the release\nsemantic-release version\nAt this point all 3 packages are released! üéâ\n\nCoding ‚Üí Committing ‚Üí Releasing\nMake changes in core:\n\n# NOTE: change dir to project's root folder\nsed -i'' -e 's/\\(hi from core\\)/\\1 - updated!/' ./packages/core/src/uvws_core/__init__.py\ngit add ./packages/core/src/uvws_core/__init__.py\ngit commit -m \"fix(core): Update hi function\"\ngit push origin main\nRelease the updated package:\n\ncd packages/core\nsemantic-release version\nSince we committed a minor (fix) change, this will bump to 0.0.2.\n\ngit tag -l |grep core\n# core-0.1.0\n# core-0.1.1\n# core-0.1.2\nCheck the changelog:\n\ncat ./packages/core/CHANGELOG.md\nIf you try to release other packages like svc1, nothing will be released since there are no changes to svc1 after the svc1‚Äì0.1.0 tag.\n\nRelease via Github Actions\nLets automate the release process via a github action:\n\nPushed commits that contain files to a package(s) will trigger a release for that specific package automatically.\nAll packages will be monitored for releases including core, svc1 and the uvwsroot package.\nThe GitHub Action files\n# NOTE: change dir to project's root folder\nmkdir -p ./.github/workflows\n# a reusable workflow to release any package\ncurl https://github.com/asaf/uvws/blob/main/.github/workflows/release-package.yml -o ./.github/workflows/release-package.yml\n# the actual release workflow, releasing core, svc1 and the uvws root package\ncurl https://github.com/asaf/uvws/blob/main/.github/workflows/release.yml -o.yml\n# a script syncing the repo to latest\ncurl https://raw.githubusercontent.com/asaf/uvws/refs/heads/main/scripts/update_package_deps.py -o ./scripts/update_package_deps.py\ngit add .github/*\ngit commit -m 'build: release automations via github action'\ngit push origin HEAD:main\nAdd a secret named PYPI_API_TOKEN to the repo via UI or CLI containing the pypi token.\necho \"my_token\" | gh secret set PYPI_API_TOKEN --repo <user>/<repo>\nTry to commit and push to main or beta, which will auto trigger a release and push the built artifact to PYPI.\n\nWrapping Up\nThis automated release workflow is exactly how we manage Flux0, ensuring our multi-agent framework stays versioned, documented, and seamlessly published. By combining uv workspace and python-semantic-release (PSR), we eliminate manual versioning headaches and maintain a smooth development pipeline.\n\nIf you‚Äôre interested in AI-powered open source assistant orchestration, multi-agent frameworks, or how Flux0 leverages this setup, check out Flux0@github\n\nMonorepo\nPython\nUv\nSemantic Release\nAutomation\nWritten by Asaf Shakarzy\n16 followers\n¬∑\n10 following\nNo responses yet\nTo respond to this story,\nget the free Medium app.\n\nOpen in app\nMore from Asaf Shakarzy\n\n\nAsaf Shakarzy\n\nDeploy and Protect Azure Container Apps (ACA) with Cloudflare\nDeploying containerized apps with Azure Container Apps (ACA) is a breeze, but what if you could secure and manage both your frontend and‚Ä¶\nJul 27, 2024\n33\n\n\n\n\nAsaf Shakarzy\n\nSetting Up a Minimal React Library Workspace with TypeScript, tsup, Biome, Vitest and Storybook\nWhen building a React component library, it‚Äôs easy to get lost in bloated configurations, unnecessary dependencies, and complex tooling‚Ä¶\nFeb 23\n50\n1\n\n\n\n\nAsaf Shakarzy\n\nEmbedding a React Frontend Inside a FastAPI Python Package (in a Monorepo)\nYou‚Äôve built a FastAPI backend and a React frontend‚Ää‚Äî‚Äänow what? Instead of juggling separate deployments, why not embed the React app‚Ä¶\nJun 30\n\n\nSee all from Asaf Shakarzy\nRecommended from Medium\n\n\nPhilip Mutua\n\n‚ö° Python UV + pyproject.toml: The Fastest Way to Run Python Apps\n‚ÄúWhat if package installs took seconds‚Ää‚Äî‚Äänot minutes?‚Äù\nJul 1\n22\n\n\n\n\nIn\n\nPython in Plain English\n\nby\n\nYaw Amponsah\n\nThe Great Python Package Manager Battle: Poetry vs UV (A Developer‚Äôs Honest Journey)\nOr: How I Learned to Stop Worrying and Love the Rust-Powered Speed Demon\nAug 19\n3\n1\n\n\n\n\nYanxing Yang\n\nGetting Started with uv: A Modern Python Environment and Package Manager\nGetting Started with uv\nMay 30\n11\n\n\n\n\nnairihar\n\nMonorepo: From Hate to Love\nWhen and How a Backend Monorepo Can Be a Better Choice\nJun 7\n69\n\n\n\n\nAlex Hruska\n\nNotebook Wars: Jupyter Notebooks with Cursor Agent\nFor part one of my Notebook Wars exploration of the various modern notebook options I will start with Jupyter Notebooks in Cursor. This is‚Ä¶\nJun 22\n3\n\n\n\n\nIn\n\nGoogle Cloud - Community\n\nby\n\nRomin Irani\n\nTutorial¬†: Getting Started with Google Antigravity\nWelcome to the tutorial on Antigravity, Google‚Äôs free and experimental Agent first development platform.\nNov 19\n423\n10\n\n\nSee more recommendations\nAll your favorite parts of Medium are now in one sidebar for easy access.\nOkay, got it\n\nWelcome back. You are signed into your member account jo‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢@gmail.com. Not you?"
  }
]
